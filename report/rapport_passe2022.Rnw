% !arara: xelatex:  { action: nonstopmode, synctex: True }
% arara: biblatex
% !arara: makeglossaries
% arara: xelatex: {action: nonstopmode, synctex: True }
% arara: xelatex: {action: nonstopmode, synctex: True }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 
%%   L'encodage de ce fichier doit être UTF-8
%%	 lancer avec Knitr + Xelatex
%%   Liste des choses à faire pour mettre à jour le rapport en nouvelle version
%%   voir issue #1 https://github.com/Eaux-et-Vilaine/passe_bassins/issues/1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%DIV=calc, qui crée une page avec 60 à 70 signes par ligne, dépend bien
%évidemment de la fonte choisie
\documentclass[11pt,twocolumn,titlepage,twoside]{article} 
\usepackage{float}
\usepackage[section]{placeins}  %The placeins package provides the command \FloatBarrier
%%============================================================
%%============================================================
%% PACKAGE SETUP

%\SweaveOpts{pdf=TRUE, echo=FALSE, fig=FALSE, eps=FALSE, tidy=T, width=4,
%height=4, keep.source=TRUE}
%% Input and language packages.
\usepackage[UTF8]{inputenc} %encodage du fichier source
\usepackage[T1]{fontenc}  %gestion des accents (pour les pdf) 
\usepackage{aeguill} % guillemets
%\usepackage[english]{babel}
% 'babel/polyglossia' detected but 'csquotes' missing.
\usepackage[french]{babel}
\usepackage{csquotes}
\usepackage{amsmath} %equation
\usepackage{fontspec}
\usepackage{unicode-math}
\usepackage{microtype}
\defaultfontfeatures{Scale=MatchLowercase}
\setmainfont{Segoe UI}[
   Scale = 1.0,
   BoldFont = Segoe UI Semibold ,
   BoldItalicFont = Segoe UI Semibold Italic]
\setmathfont{Segoe UI}
%\setmathfont{Segoe UI Italic}
%\setmathfont{Segoe UI Semibold Italic}
%Selecting fonts locally
% If you want to use a font for a small section of your document it's best to
% define a new font family called with comment \titlefont{...}
\newfontfamily\titlefont{Georgia} 



%% Parskip is the extra vertical space inserted before a paragraph. It has a natural length of zero 
%but should be a rubber length so that it may be stretched in a flushbottom
% environment. To increase \parskip to skip a line between paragraphs one could use \addtolength{\parskip} {\baselineskip}.
\usepackage{parskip}



%% Sets space between lines.
\usepackage{setspace} 


\usepackage{longtable}
\usepackage{booktabs}
%% Using captions in floating environment. Note: might not work with other packages.
%\usepackage{caption}
\usepackage[labelfont={color=orange_EV,bf}]{caption} % pour éviter les problème de
% place entre le header et le tableau et légendes en gras
\addto\captionsfrench{\renewcommand*{\contentsname}{Sommaire}}
\captionsetup[table]{skip=5pt}
\def\frenchtablename{Tableau}
\renewcommand{\thefigure}{\titlefont{\arabic{figure}}}
\renewcommand{\thetable}{\titlefont{\arabic{table}}}

\usepackage{wrapfig}	
\usepackage{rotating} % to roate the picture% wrapping text around figures
%% If you use PostScript figures in your article
%% use the graphics package for simple commands
%\usepackage{graphics}
%% or use the graphicx package for more complicated commands 

\usepackage{graphicx}
%(places the float at precisely the location in the LaTeX code [H]).
\usepackage{float}


%% Pour faire des listes numérotées ou à partir de symboles
\usepackage{enumerate}

% si on charge les deux ça clash
%\usepackage{enumitem} % Customize lists
%\setlist{nolistsep} % Reduce spacing between bullet points and numbered lists

% package pour les unités
\usepackage{siunitx} % for unit %\SI{1.55}{\micro\metre}
\DeclareSIUnit{\adult}{Adulte}
\DeclareSIUnit{\juvenile}{Juvenile}
\DeclareSIUnit{\ind}{Ind.}
\DeclareSIUnit{\year}{An}
\sisetup{range-phrase=~à~,range-units =single, table-number-alignment =right,
table-figures-exponent=1}
%per-mode = symbol


%% The verbatim environment, \begin{verbatim} ... \end{verbatim}, permits us to insert large sections of reformatted text in a LaTeX file (including block of comments). It is very handy for inserting large chunks of code in a document, for example, literal TeX code or the Maple code you sweated over and now want to comment on.
%\usepackage{verbatim}

%% Add hyperlinks, so that you can click on references, theorem numbers etc. to jump to the place where they are in the paper (at least for the DVI and PDF versions), it seems that \documentclass{article} does not work with hyperref; use instead \documentclass{amsart}. Note: first test it with Elsevier template!
\usepackage{hyperref} 

\usepackage{xcolor} % Required for specifying colors by name
\definecolor{bleu_EV}{RGB}{0,33,143}
\definecolor{turquoise_EV}{RGB}{0,201,196}
\definecolor{orange_EV}{RGB}{255,117,87}
\definecolor{jaune_EV}{RGB}{255,180,40}
\definecolor{bleuazur}{RGB}{48,113,162}
\definecolor{marron}{RGB}{70,40,0}
\definecolor{bleu_EVf}{RGB}{0,19,80}
\definecolor{jaune_EVf}{RGB}{173,112,0}
\definecolor{turquoise_EVf}{RGB}{0,120,115}
\definecolor{orange_EVf}{RGB}{178,81,60}
\definecolor{bleu_clair_EV}{RGB}{51,181,255}
\hypersetup{
colorlinks=true, 
linkcolor=orange_EVf, 
citecolor=orange_EV, 
filecolor=bleu_EV, 
urlcolor=bleu_EV, 
pdftitle= {Suivi scientifique des migrations de poissons de la passe à bassins
du barrage d'Arzal, Rapport 2022)}, 
pdfauthor={Brice Sauvaget},
pdfsubject={mulet}, 
pdfkeywords={passe} {lamproies} {alose} {stacomi}
}

\newcommand\colcitep[2]{\begingroup\hypersetup{citecolor=#1}\citep{#2}\endgroup}





%% The numcompress package shorten the last page in references.
%% `nodots' option removes dots from firstnames in references.
%\usepackage[nodots]{numcompress}

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers after \end{frontmatter}.
%% \usepackage{lineno}

%% If you are printing how many pages you submitted...
\usepackage{lastpage}

%% The \url{...} command does all the work: It sets the enclosed expression in the appropriate typewriter style font, it takes care of any necessary linebreaking, and it chooses break points intelligently (e.g., between components of an address), and it ensures that special symbols such as the tilde symbol or the "at" symbol get typeset correctly.
\usepackage{url}

%% A new implementation of LATEX's tabular and array environment.
 \usepackage{array}
 

%%============================================================
%% BIBLIOGRAPHY SETUP
%%============================================================
\usepackage[style=authoryear, %numeric
            natbib=true, % citep and citet
            %backend=biber, % default for biblatex
            bibencoding=utf8,
            url=false, 
            doi=false,
            uniquename=init,
            firstinits=true, % pas de prenoms
            %sorting=nyt, % name, year, title
            eprint=false]{biblatex} % option natbib to use cite and citep
\addbibresource{rapport_passe.bib}


%%============================================================
%%============================================================
%% PAGE SETUP
%% Use this section to override Elsevier article page settings!!!

	%% Easier way...
\usepackage[a4paper, inner=1.5cm, outer=1.5cm, top=2cm, bottom=3cm]{geometry}
%% The hard way involves setting all the desired values manually. Here are some values that can be set: 
%% Dimensions of the PDF file.
%\pdfpageheight \pdfpagewidth
%% Length of margin at top of page above all printing. 1 inch is added to this value.
%\topmargin   
%% Left margin on even numbered pages. 1 inch is added to this value.
%\evensidemargin  
%% Left margin on odd numbered pages. 1 inch is added to this value.
%\oddsidemargin
%% Height of the page header.
%\headheight
%% Distance from bottom of header to the body of text on a page.
%\headsep
%% Distance from top of main text box to the baseline of the first line of text in the main text box.
%\topskip 
%% Height and width of main text box.
%\textheight \textwidth
%% Distance from bottom of body to the bottom of the footer.
%\footskip
%% Distance between paragraphs.
%\parskip
%% Amount of indentation at the first line of a paragraph.
%\parindent
%% Uncomment if don't want page numbers.
%\pagestyle{empty}
%% Uncomment for 1.5 spacing between lines...
%\renewcommand{\baselinestretch}{1.5}
%% or use some of these
%\singlespacing
%\onehalfspacing
%\doublespacing
%\setstretch{1.1}
%% Sets up hyphenation threshold.
%\hyphenpenalty=675 \tolerance=950


%----------------------------------------------------------------------------------------
%	PAGE HEADERS (this must come after loading and setting geometry)
%----------------------------------------------------------------------------------------

\usepackage{fancyhdr} % Required for header and footer configuration

\pagestyle{fancy}

% Chapter text font settings
\renewcommand{\sectionmark}[1]{\markright{\sffamily\normalsize\thesection\hspace{7pt}#1}{}}
%\renewcommand{\subsectionmark}[1]{\markboth{}{\sffamily\normalsize\thesubsection\hspace{7pt}#1}}
% Section text font settings
\fancyhf{} \fancyfoot[C]{\sffamily\normalsize\thepage} % Font setting for
% the page number in the header
\fancyhead[LE,RO]{\sffamily \rightmark}
\fancyhead[LO,RE]{\slshape \normalsize Rapport passe à bassins 2022}




\renewcommand{\headrulewidth}{0.5pt} % Width of the rule under the header (slightly more than 0.4 pt)
\addtolength{\headheight}{2.5pt} % Increase the spacing around the header slightly
\renewcommand{\footrulewidth}{0pt} % Removes the rule in the footer
\fancypagestyle{plain}{\fancyhead{}\renewcommand{\headrulewidth}{0pt}} % Style for when a plain pagestyle is specified



%%============================================================
%%============================================================
%% DEFINING NEW COMMANDS AND ABBREVIATIONS
%% Use this section to define new commands that you will use in
%% your report.

%% Makes a path to your graphics' folder.
\graphicspath{{../image/}}

\newcommand{\tab}{\hspace*{2em}}
\newcommand{\DD}{D\&D}
\newcommand{\oxygen}{O$ _2 $}

\renewcommand{\labelitemi}{--}
\usepackage{tikz} % Required for drawing custom shapes
%----------------------------------------------------------------------------------------
%	TO POSITION WITH TKIZ (definition commande page)
% https://tex.stackexchange.com/questions/89588/positioning-relative-to-page-in-tikz 
%
% ----------------------------------------------------------------------------------------
\makeatletter
\def\parsecomma#1,#2\endparsecomma{\def\page@x{#1}\def\page@y{#2}}
\tikzdeclarecoordinatesystem{page}{
    \parsecomma#1\endparsecomma
    \pgfpointanchor{current page}{north east}
    % Save the upper right corner
    \pgf@xc=\pgf@x%
    \pgf@yc=\pgf@y%
    % save the lower left corner
    \pgfpointanchor{current page}{south west}
    \pgf@xb=\pgf@x%
    \pgf@yb=\pgf@y%
    % Transform to the correct placement
    \pgfmathparse{(\pgf@xc-\pgf@xb)/2.*\page@x+(\pgf@xc+\pgf@xb)/2.}
    \expandafter\pgf@x\expandafter=\pgfmathresult pt
    \pgfmathparse{(\pgf@yc-\pgf@yb)/2.*\page@y+(\pgf@yc+\pgf@yb)/2.}
    \expandafter\pgf@y\expandafter=\pgfmathresult pt
}
\makeatother
\usepackage{eso-pic,graphicx}


\usepackage[framemethod=TikZ]{mdframed} % Required for creating the theorem, definition, exercise and corollary 

\usepackage{pdflscape}
\usepackage[most]{tcolorbox} % box for summary at the end 
% chapitre avec couleur
\usepackage[explicit]{titlesec} % explicit says you must use #1 below
% \titleformat{hcommandi}[hshapei]{hformati}{hlabeli}{hsepi}{hbefore-codei}[hafter-codei]
\newlength\secnumb
\setlength\secnumb{2cm}
%https://borntocode.fr/latex-personnaliser-les-titres-chapter/
\titleformat{\section}[block]  %display et frame. La première est celle
% utilisée par défaut par les titres de latex, elle sépare le titre du prochain paragraphe. La seconde permet d’ajouter un cadre autour du titre
    {\LARGE\textcolor{bleu_EV}\titlefont}
    {}
    %hformati is the format to be applied to the whole title—label and text.
    % This part can contain vertical material (and horizontal with some shapes) which is typeset just after
    %the space above the title.
    {0pt} %hsepi is the horizontal separation between label and title body and
    %must be a length (it must not be empty). This space is vertical in display
    % shape; in frame it is the distance from text to frame. Both hlabeli and hsepi are ignored in starred versions of sectioning
    %commands. If you are using picture and the like, set this parameter to 0
   % pt.
    { 
     \parbox[b]{\secnumb}{
      \fontsize{50}{60}\selectfont\titlefont\textcolor{bleu_EV}{\thesection}}
      % {1} must be 1.2 {2}
      \parbox[b]{\dimexpr\columnwidth-\secnumb-2em\relax}{
        \raggedleft
        \hfill{\LARGE\titlefont\textcolor{bleu_EV}{#1}}\\
        \textcolor{bleu_EV}{\rule{\dimexpr\columnwidth-\secnumb-2em\relax}{0.4pt}}
        }}
    
 % pour les chapitres sans numéro
 %Both hlabeli and hsepi are ignored in starred versions of sectioning
%  commands. 
\titleformat{name=\section,numberless}[block]  
    {\LARGE\textcolor{bleu_EV}\titlefont}
    {}
    {0pt} 
    {\parbox[b]{\chapnumb}{%
   \mbox{}}%
    \parbox[b]{\dimexpr\columnwidth-\secnumb-2em\relax}{
        \raggedleft
        \hfill{\LARGE\titlefont\textcolor{bleu_EV}{#1}}\\
        \textcolor{bleu_EV}{\rule{\dimexpr\columnwidth-2em\relax}{0.4pt}}
        }%
     }
\titleformat{\subsection}[display]    % hand is the default for sections but use display to avoid par extending over the margin
        {\Large\titlefont}
        {\textcolor{bleu_EV}
        {\subsectiontitlename \thesubsection \quad #1}}
        {0pt}
        {}
\titleformat{\subsubsection}[display]    % hand is the default for sections
        {\titlefont}
        {\textcolor{bleu_EV}
        {\subsubsectiontitlename \thesubsubsection \quad #1}}
        {0pt}
        {}
        
%\titlespacing*{<command>}{<left>}{<before-sep>}{<after-sep>}
\titlespacing*{\section}{0}{4.5ex plus 1ex minus .2ex}{3.3ex plus .2ex}
\titlespacing*{\subsection}{0}{3.5ex plus 1ex minus 1ex}{1ex plus .2ex}
\titlespacing*{\subsubsection}{0}{2.5ex plus 1ex minus 1ex}{0.5ex plus .1ex}
%%===============================================%%
%%==========    END OF THE PREAMBLE    ==========%%
%%===============================================%%


%%============================================================
%%============================================================
%%============================================================
% BEGINNING OF THE TEXT BODY

%% You can write here small footer that will go on the first page, together with
%% the date stamp; comment the line if you don't want that!
%\footme{Submitted to Someone Somewhere\hspace{2mm}(\pageref{LastPage} pages)} \datestamp{Andrej Korenic, 27$^{th}$ October, 2011}

\begin{document}
\newgeometry{right=0.5cm, left=1.5cm, top=1cm, bottom=1cm}
\begin{titlepage} 
\thispagestyle{empty}
\begingroup % similar to { with all settings are confined to this group ... 
% for this command creates a background picture to the title page
\AddToShipoutPicture*{\put(0,0){%
\parbox[b][\paperheight]{\paperwidth}{%
\vfill
\includegraphics[%width=\paperwidth,
height=\paperheight,%
keepaspectratio]{/frontpage.png}%
%\vfill
}}}%

\hfill%
\begin{minipage}{0.28\textwidth}

\par\sffamily\selectfont
\vspace{4cm}
\Large 
    {\titlefont Suivi scientifique des migrations de poissons 
    de la passe à bassins du barrage d'Arzal.
    Rapport 2022.}\\
\vspace{2cm}

\includegraphics[width=\textwidth]{/logo_EV} 
\end{minipage}
\vfill
\vspace{1.5cm}
\hfill%
\begin{minipage}{0.28\textwidth}
\textbf{
{\titlefont Date d'édition :\\}}
\qquad \color{orange_EV}
\Large
{\titlefont Août 2022}
\vspace{2cm}

\end{minipage}

       
    
\hfill{ %
\begin{minipage}{0.28\textwidth}
\textbf{Réalisé avec le concours de} : \par
\vspace{1cm}
% le logo de l'agence doit au moins faire 25 mm de haut      
\centering{\includegraphics[height=20mm]{/logo_agence.png}} 
\includegraphics[height=20mm]{/logo_region_bretagne.png}
\end{minipage}
}%  
\vfill
\hfill{ %
\begin{minipage}{0.3\textwidth}
\large
\color{bleu_EV}
\leftskip=1cm
Cédric Briand\par   
Brice Sauvaget\par
Gérard Eriau\par
\vspace{1cm}
\end{minipage}
}% 
\endgroup
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\newgeometry{right=1.5cm, left=1.2cm, top=0.2cm, bottom=2cm}
\thispagestyle{empty}
\pagecolor{bleu_EV}
\newgeometry{margin=0cm}
\begin{minipage}{\textwidth}
\vspace{30pt}
\hspace{30pt}
\includegraphics[width=6cm,keepaspectratio=true]{/logo_EV1}
\end{minipage}

%\vspace*{0cm}
\begin{minipage}{0.1\textwidth}
\phantom{This text will be invisible}
\end{minipage}
\begin{minipage}{0.8\textwidth}
\begin{center}
\noindent
{\color{turquoise_EV}\rule{\textwidth}{2.5pt}}\\
\vspace{8mm}
\color{white}
{ \titlefont \huge  \bfseries{Suivi scientifique des migrations de poissons 
    de la passe à bassins du barrage d'Arzal,\\
    }}
\bigskip
{\titlefont  \LARGE rapport 2022\par }
\vspace{4mm}\noindent
{\color{turquoise_EV}\rule{0.9\textwidth}{1.8pt}}\par
\vspace{5mm}
{\color{jaune_EV}{\titlefont \Large \itshape{Brice Sauvaget,
      Gérard Eriau,
      Cédric Briand\par   }}}
\end{center}
\end{minipage}



\vspace{2cm}
\includegraphics[width=\paperwidth]{ala.png}

\vspace{2cm}
\begin{minipage}{0.8\textwidth}
\begin{center}
\hspace{3cm}{\color{white}{\huge \itshape{Août 2022}}}
\end{center}
\end{minipage}
\restoregeometry
\clearpage
\normalsize
\pagecolor{white}



<< knitropt, echo=FALSE, include=FALSE >>=
# petite fonction de Laurent pour charger les packages quand ils ne sont pas installés
#' @title load_package function, same as above but individual, and not using installed.packages
#' @description load and if needed install package(s)
#' @param x name of the library/ries to be loaded
load_package <- function(x)
{
  if (!is.character(x)) stop("Package should be a string")
  if (!require(x,character.only = TRUE))
  {
    install.packages(x, lib=.libPaths()[1],repos="http://cran.us.r-project.org", dep=TRUE)
    if(!require(x,character.only = TRUE)) stop("Package not found")
  }
}
load_package("knitr")
opts_knit$set(base.dir="C:/workspace/pdata/traitement_stacomi/rapport_passe/image")
opts_knit$set(eval=FALSE, message=FALSE, warnings=FALSE, error=FALSE)
# this will cause R to stop on errors
# include = FALSE nothing will be produced from chunks
# warnings= FALSE, all warnings will be printed in the console instead of the output document
@

<<init,echo=FALSE,eval=TRUE,include=FALSE>>=
#options(encoding = "UTF-8")
# (first you need to have the destination file as "UTF-8")
# Use this option for xtable if run from knitr
# Don't set any option if you are running straight from R
# for writing images with plot or ggplot
# running from knitr is OK
#  To get the right result running straight you need to convert each string
# using iconv("Année","UTF-8")
Sys.setenv(LANGUAGE = "fr")
#######################################################################"
# dans le fichier "C:\Program Files\R\R-3.3.2\etc\Rprofile.site" 
# je stocke mes password admin qui sont chargés au lancement des sessiosn R
# .First <- function(){
# passwordlocal<<-"********************"
# passworddistant<<-"*******************"
# cat("\n Creation des passwords passwordlocal passworddistant", date(), "\n") 
#}
# pour sauvegarde de la base iav
#pg_dump -U postgres -f "iav.sql" --schema iav -h w3.eptb-vilaine.fr bd_contmig_nat_iav
# pour restauration en localhost
# psql -U postgres -f "iav.sql" bd_contmig_nat
###########################################################################
# ci dessous nettoye tout sauf mes deux password
# attention de bien configurer bd_contmig_nat pour qu'il pointe vers la base bd_contmig_nat_iav
obj <- ls(all=TRUE)
obj <- obj[!obj%in%c("pois","passworddistant","passwordlocal","userdistant","hostdistant","umysql","hostmysql","pwdmysql")]
rm(list=obj) # nettoyage complet sauf passwords
# fermeture de tous les graphiques
graphics.off()

setwd("C:/workspace/passe_bassins/report/")

datawd<-"C:/workspace/passe_bassins/data/"
load_package <- function(x)
{
  if (!is.character(x)) stop("Package should be a string")
  if (!require(x,character.only = TRUE))
  {
    install.packages(x, lib=.libPaths()[1],repos="http://cran.us.r-project.org", dep=TRUE)
    if(!require(x,character.only = TRUE)) stop("Package not found")
  }
}
load_package('getPass')
load_package('magrittr')
load_package('Hmisc')
load_package('xtable')
load_package('stacomirtools')
load_package("stringr")
load_package("stargazer")
load_package('lubridate')
load_package('reshape2')
load_package('dplyr')
load_package('readxl')
load_package('stacomiR')
load_package('tables')
load_package('colorspace')
load_package('RPostgres')
load_package('glue')
load_package('getPass')
load_package('stringr')
load_package('hubeau')


# l'annee en cours (c'est la valeur à changer en début de script
CY <- 2022
# le repertoire contenant les données
datawdy <- str_c(datawd,CY,"/")
dir.create(datawdy,showWarnings = FALSE)
datawdym1 <- str_c(datawd,CY-1,"/")
# le repertoire contenant mes images (très important pour sweave)
imgwd <- "C:/workspace/passe_bassins/image/"
# le répertoire contenant les tableaux en latex
tabwd <- "C:/workspace/passe_bassins/table/"
# en vrai les données annuelles sont dans des sous répertoires par année
imgwdy <- str_c(imgwd,CY,"/")
dir.create(imgwdy, showWarnings = FALSE)
tabwdy <- str_c(tabwd,CY,"/")
dir.create(tabwdy, showWarnings = FALSE)
# une petite option pour simplifier la construction des tableaux en latex
# avec xtable, par défaut je ne veux pas des titres des lignes
options("xtable.include.rownames"=FALSE)

#'==========================================================
#' fonction d'impression des nombres
#'==========================================================
sn <- function(x,digits=0,scientific=FALSE)
{
  if (class(x)=="character") {                
    warning("sn appliqué a un character")
    return(x)
  }
  if (is.infinite(x)) {                
    warning("sn appliqué à Inf")
    return(x)
  }
  if (length(x)==0) {                
    warning("sn length 0")
    return("???")
  }
  if (x==0) return("0")
  ord <- floor(log(abs(x),10))
  if (scientific==FALSE&ord<9){
    if (digits==0) {
      digits=max(1,ord) # digits must be >0
      nsmall=0
    }else {
      nsmall=digits
    }
    x<-format(x,big.mark="~",small.mark="~",digits=digits,nsmall=nsmall)
    return(str_c("$",as.character(x),"$"))                
  } else {
    x <- x / 10^ord
    if (!missing(digits)) x <- format(x,digits=digits)
    if (ord==0) return(as.character(x))
    return(str_c("$",x,"\\\\times 10^{",ord,"}$"))
  }
}
#'==========================================================
#' fonction d'application de la transparence à des couleurs.
#'==========================================================
makeTransparent = function(..., alpha=0.5) {
  
  if(alpha<0 | alpha>1) stop("alpha must be between 0 and 1")
  
  alpha = floor(255*alpha)  
  newColor = col2rgb(col=unlist(list(...)), alpha=FALSE)
  
  .makeTransparent = function(col, alpha) {
    rgb(red=col[1], green=col[2], blue=col[3], alpha=alpha, maxColorValue=255)
  }
  
  newColor = apply(newColor, 2, .makeTransparent, alpha=alpha)
  
  return(newColor)
  
}
#'==========================================================
#' Fonction de nettoyage
#'==========================================================


#str <- "~!@#$%^&*(){}_+:<>?\r\n,./;'[]-\\"
# sanitize(str)
# NOTE THIS FUNCTION WILL WORK WITH KNITR NOT SWEAVE !
sanitize <- function(str) {
  str <- gsub("\\r\\n","",str)
#	str <- stringi::stri_replace_all_fixed(str, c("\\"),
#			c("\\\\"),vectorize_all=FALSE)	
  
#	str <- stringi::stri_replace_all_fixed(str, c("{","}"),
#			c("\\{","\\}"),vectorize_all=FALSE)	
  str <- stringi::stri_replace_all_fixed(str, c("#","$","%","&","~","_","^"),
      c("\\#","\\$","\\%","\\&","\\~{}","\\_","\\^{}"),vectorize_all=FALSE)
  return(str)
}

#'==========================================================
#' Quelques options de couleur
#' ==========================================================
mycolorramp1<-colorRampPalette(c("#001350","#4F7EA2")) #bleuEV très foncé
mycolorramp2<-colorRampPalette(c("#462800","#B68B52"))
col1<-makeTransparent(mycolorramp1(8),0.1)[1:6]
col2<-makeTransparent(mycolorramp2(8),0.1)[1:6]
couleur_mois_tr<-c(col1,rev(col2))
col1<-mycolorramp1(8)[1:6]
col2<-mycolorramp2(8)[1:6]
couleur_mois<-c(col1,rev(col2))
rm(col1,col2)

#bleufonce <- rgb(4, 60, 107, 255, maxColorValue = 255)
bleu_EV <- rgb(0, 33, 143, 255, maxColorValue = 255)
bleu_EV <- "#00218f"
turquoise_EV <- "#00C9C4"
orange_EV <- "#ff7557"
jaune_EV <- "#ffb428"
marron <- rgb(70, 40, 0, 255, maxColorValue = 255)
bleu_EVf <- "#001350"
jaune_EVf <- "#AD7000"
orange_EVf <- "#b2513c"
bleu_clair_EV <- "#33b5ff"
turquoise_EVf <- "#007873"




col <- c("#17364E","moccasin","#B68B52","#765223","grey")
image(1:length(col), 1, as.matrix(1:length(col)), 
    col=col,
    xlab="", ylab = "", xaxt = "n", yaxt = "n", bty = "n")


#'==========================================================
#' Fonction pour charger les nombres avec le package SIUNITX dans
#' LATEX et pour colorer les valeurs générées dynamiquement
#' ==========================================================
color_num_text <- "orange_EV"
num <- function(x, round_precision =  NULL, color=color_num_text)
{
  if (is.null(color)){
    if (is.null(round_precision)) {
      return(sprintf("\\num{%s}", x))
    } else {
      return(sprintf("\\num[round-precision=%s]{%s}",round_precision+1, x))
    }
  } else {
    if (is.null(round_precision)) {
      return(sprintf("\\textcolor{%s}{\\num{%s}}", color, x))
    } else {
      return(sprintf("\\textcolor{%s}\\num[round-precision=%s]{%s}",color, round_precision+1, x))
    }
    
  }
}

###########################
# définition du thème de couleurs
###########################
color=c(
    "#052945",#working
    "#ECDAC0",#stopped
    bleu_EV,#normal "#3071A2"
    turquoise_EV, # arret ponctuel
    orange_EV,# arret maintenance "#462800"
    jaune_EV,#dysfunction "#B68B52"
    "#A66F24", # inconnu
    "#012746",#eff
    "#6C3E00",#weight
    "blue",
    "blue"
)



#'==========================================================
#' Chargement des données par défaut
#' certains chunks (bouts de code) qui suivent ne sont pas lancés 
#' de manière systématique, pour gagner du temps de compilation
#' du coup je stock les résultats intermédiaires dans une liste
#' nommée vvv. Le script vérifie si elle existe, sinon il la crée
#' car il faudra la recréer lorsqu'on relancera le script lors d'une
#' nouvelle année de traitement.
#'==========================================================
if (file.exists(file=str_c(datawdy,"vvv.Rdata"))){
  load(file=str_c(datawdy,"vvv.Rdata"))
} else {
  #crétation de la variable vvv
  vvv<-list()
}
#'==========================================================
#' Option de base donnée
#'==========================================================


if (exists("userdistant") & exists("passworddistant") & exists("hostdistant")) {
  if( !exists("pois")) pois <- getPass(msg="main password")
  host <- decrypt_string(hostdistant,pois)
  user <- decrypt_string(userdistant,pois)
  password<- decrypt_string(passworddistant,pois)
} else {
  host <- getPass(msg="host")
  user <- getPass(msg="user")
  password <- getPass(msg="password")
}

options(list(
        stacomiR.dbname = "bd_contmig_nat_iav",
        stacomiR.host = host,
        stacomiR.port = "5432",
        stacomiR.user = user,
        stacomiR.password = password,
        stacomiR.printqueries =FALSE
    ))
stacomi(TRUE,sch="iav", datawd=datawd)

@




  


\tableofcontents



%% Switch on the line numbers for the whole article at this place.
%\linenumbers


%% Main text is going here.

\bigskip



\section*{Introduction}
\label{Introduction}
L'estuaire de la Vilaine est limité à sa portion aval par le barrage d'Arzal,
construit par l'IAV en 1970, et qui bloque l'onde de marée à 10 km de
l'embouchure de l'estuaire.
L'estuaire en amont, jusqu'à la limite historique de l'estuaire tital (barrages de Malon et de la Potinais à 70-80 km en amont) 
a été transformé en rivière. Le plan d'eau ainsi créé a vu se développer de
nouveaux usages dont les principaux sont la navigation et
l'eau potable.
Le barrage d'Arzal joue aussi un rôle majeur dans la protection contre les crues de l'aval du bassin versant, 
en empêchant les conjonctions de
forts débits amont et d'importantes surcotes de marées.
Ce barrage constitue ainsi une rupture nette entre des eaux saumâtres et douces. Il évacue le débit
de la Vilaine qui avec 12400 km$^2$ couvre le tiers de la surface la Bretagne.
Le barrage d'Arzal est un obstacle majeur à la circulation
des poissons migrateurs. Entre 1970 et 1995, année de la mise en service de dispositifs de franchissements,
leurs populations ont très fortement régressé sur le fleuve, voire même disparu.
Les passes à poissons du barrage d'Arzal, mises en service à l'automne 1995, 
font l'objet d'un suivi régulier. En 1996 et 1997, les migrations dans la passe à bassins 
ont été comptabilisées sur l'ensemble de l'année. Entre 1998 et 2012, seule la période favorable 
(généralement de mars à juin) fait l'objet d'un suivi. Depuis 2013, le suivi est à nouveau annuel. 


Ce rapport décrit le fonctionnement de la passe à fentes verticales du barrage
et de son système de vidéosurveillance associé. Il fait également la synthèse des passages de 
poissons migrateurs par la passe à bassins en 2022 \footnote{la migration sur
les passes à anguilles est traitée dans un autre rapport :
\href{https://eptbvilaine56.sharepoint.com/:b:/g/extranet/EcGiQiXYob5AhBZwXXY2zk0B-mRcDpfq8uo0_f-1p4pCoA?e=3I4Nah}{Gestion
de l'anguille sur le bassin versant de la Vilaine}.}.

   
    
\section{Matériel et méthodes}

\subsection{Site d'étude}
\subsubsection{Le barrage}

L’ouvrage, édifié entre 1965 et 1970, est constitué d’une partie centrale de 160 mètres comprenant 5 vannes 
et une écluse, et d’une digue en terre de 360 mètres (Photo
\ref{photo_barrage}).
Il bloque l’onde de marée à 12 kilomètres de l’embouchure et constitue une rupture nette entre le milieu estuarien 
et le plan d’eau douce artificiellement créé à l’amont. 
Le marnage à l’aval est de 7 mètres lors des grandes marées (Figure
\ref{photo_barrage}).

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{barrage.png}
\caption{Photographie aérienne du barrage d'Arzal.
}
\label{photo_barrage}
\end{figure}


\subsubsection{La passe à bassins}

Deux passes ont été construites en 1995 sur le barrage. La première est un
dispositif spécifique pour les anguilles composé de rampes de reptation plongeant dans l'estuaire et
permettant aux anguillettes et aux civelles de grimper le long des rampes en
prenant appui sur des brosses, puis plus en amont d'un piège, un vivier de
stockage dans lequel les anguilles tombent après avoir franchi la rampe.
La deuxième est la passe à bassins successifs dont le suivi fait l'objet de ce
rapport.
Elle est composée de 9 bassins successifs reliés entre eux par des fentes
verticales \citep{larinier_passes_1999}.
Des chutes s’établissent entre les bassins et permettent de passer de la cote de l’estuaire à la cote du plan d’eau amont
(la passe constitue une sorte d’escalier hydraulique). Le poisson est attiré à
l’entrée de la passe par un courant d’eau douce. Il va remonter successivement
la chute aval et les différents bassins de la passe à poissons (2) pour se
retrouver à l’amont du barrage au niveau de la
chambre de visualisation (3) (Figure \ref{figure_passe_bassins}).

\begin{figure}[htpb]
\centering
\includegraphics[width=0.35\textwidth]{passe_bassins.png}
\caption{Reconstitution pédagogique vue de dessus et en 3D de la passe à bassins du barrage d’Arzal.
}
\label{figure_passe_bassins}
\end{figure}

Les paramètres hydrauliques de la passe conditionnent le passage des espèces migratrices : le courant doit être suffisant
pour attirer le poisson vers l’entrée de la passe, mais pas trop puissant pour lui permettre de franchir les chutes
qui s’établissent entre chaque bassin. Ces paramètres doivent rester compris dans une gamme de valeurs permettant 
le franchissement des espèces que l’on désire faire passer. Ils dépendent étroitement du niveau d’eau amont et de
la hauteur de chute qui s’établit en entrée de passe. Or, le niveau aval, lié à
la marée, et le niveau amont lié à la gestion du plan d’eau par le barrage, sont très fluctuants. Une série de vannes gérées par un automate permet d’adapter en permanence 
le nombre de bassins (le nombre de marches d’escalier nécessaires pour franchir le dénivelé) et la hauteur de chute aval 
(la hauteur de la première marche). La mise au point de la passe a été réalisée en 1996 et a permis de caler les 
conditions de course, d’ouverture et de fermeture des différentes vannes en
fonction du niveau de la marée \citep{briand_suivi_1998}.
La passe à bassins est franchissable par plusieurs espèces marines, avec les grands migrateurs
(saumon, truite de mer, alose, lamproie, mulet, anguille jaune) et d’autres
espèces dont les passages sont anecdotiques (bar, flet), mais également par des espèces d’eau douce dévalant en estuaire par l’écluse 
ou par les vannes lors des épisodes de forts débits (silure, carpe, amour
blanc, sandre, gardon, ablette, brème ...). 
L'usage de bassins successifs séparés par des fentes verticales permet de
s’adapter aux grandes variations de niveaux amont et aval rencontrées en estuaire.


\subsection{Fonctionnement de la passe à bassins}
\subsubsection{Principe}
Le rôle du barrage d’Arzal est de limiter au maximum les entrées d’eau salée en Vilaine. La passe à bassins, 
située à l’interface de la mer et de l’eau douce, subit donc des contraintes liées aux marées.
Un automate informatique gère les vannes aval et amont de la passe à bassins en fonction des niveaux d’eau de la mer
et de la Vilaine. La passe fonctionne seulement quand le niveau de la mer est inférieur au niveau amont. 
La contrainte de sécurité de 30 cm sert à empêcher les intrusions d’eau salée dans le plan d’eau amont. 
La passe reste en fonctionnement à basse mer mais on considère qu’au-delà de 50 cm la chute à l’aval de la passe 
n’est plus franchissable. Lorsque le niveau dans le dernier bassin à l’aval de la passe (Niveau SAS) 
est situé 50 cm en dessus du niveau mer, la passe est considérée en dysfonctionnement hydraulique.
\subsubsection{Catégories d'état de la passe à bassins}
Les fonctionnements de la passe sont classifiés suivant les standards nationaux
établis par le SANDRE dans le
\href{http://www.sandre.eaufrance.fr/notice-doc/station-de-contrôle-des-migrations-de-poissons}{guide
des stations de contrôle des migrations} :
\begin{enumerate}
\item Fonctionnement normal.
\item Arrêt ponctuel lié au fonctionnement du dispositif : marée haute.
\item Arrêt technique : la passe est arrêtée mais compte tenu du niveau de la mer, elle pourrait être en fonctionnement. 
Les limitations de fonctionnement en période d’étiage sont inclues dans cette catégorie.
\item Dysfonctionnement hydraulique : à basse mer, la hauteur de chute à l’aval empêche la migration des poissons.
\item Inconnu : pas de données provenant de la base de données du barrage.
\end{enumerate}

<<diagramme_fonctionnement_passe,echo=FALSE,eval=FALSE,include=FALSE>>=
library(DiagrammeR)
library(magrittr)
node_list <- create_node_df(n=8,		
    type=c("Niveau",
        "Niveau",
        "Type fonctionnement",
        "Type fonctionnement",
        "niveau",
        "Type fonctionnement",
        "Type fonctionnement",
        "Type fonctionnement"
    ),
    label=iconv(c("H mer - H Vilaine",
            "H vanne \n amont",
            "2",
            "3",
            "Delta sas-mer",	
            "1",
            "4",
            "5"
        ), "UTF8"),
    color=c("white",
        "white",
        orange_EV,
        "red",
        "white",
        "green",
        orange_EV,
        turquoise_EV),
    fillcolor = bleu_EV,
    style="filled",
    shape=c("plaintext","plaintext","circle","circle","plaintext","circle","circle","circle"),
    value=c(2,2,1,1,2,1,1,1),
    fixedsize =FALSE
)

edge_list<-create_edge_df(
    from=c(1,1,2,2,5,5,1,2,5),
    to=  c(2,3,4,5,6,7,8,8,8),
    rel="a",
    label=c(">0.3m","<0.3m","==0.08m","!=0.08m","<0.5m",">0.5m", "  ?", "  ?", "  ?"),
    color=c("green",orange_EV,"red","green","green",orange_EV,turquoise_EV,turquoise_EV,turquoise_EV),
    length=100)



igraph1 <- create_graph()
igraph2 <- igraph1%>%
    add_nodes_from_table(table = node_list, 
        type_col=type,
        label_col=label) 
#igraph2 %>% get_node_df()
# Add the edges to the graph
i_graph_3 <-igraph2 %>%
    add_edges_from_table(
        table = edge_list,
        from_col = from,
        to_col = to,
        from_to_map = id_external
    )


render_graph(i_graph_3, layout="nicely")

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[htpb]
\centering
\includegraphics[width=0.5\textwidth]{schema_fonctionnement_EV.png}
\caption{Diagramme schématique de l'algorithme de calcul du fonctionnement de la
passe. Les valeurs sont en mètres. La passe fonctionne pour une différence de
niveaux entre la Vilaine et la mer supérieure à 30 cm, elle est fermée quand le
codeur de la vanne amont est à la cote 0.08m, elle est ouverte pour toutes les
autres valeurs.
Un dysfonctionnement hydraulique est noté pour des valeurs de chute aval supérieures à 50 cm (lors des basses mer). En
cercles les types de fonctionnement du dispositif, 1 = Fonctionnement normal,
2 = arrêt normal dû au fonctionnement du dispositif, ici marée haute, 3 =
arrêt pour maintenance, 4 = dysfonctionnement hydraulique, 5 pas de données. Le
graphique est créé à partir du package DiagrammeR
\citep{Iannone_diagrammer_2019}.}
\label{figure_schema_fonctionnement}
\end{figure}

En pratique, il est difficile de différentier un arrêt technique de la passe et
un arrêt à marée haute. Ainsi, les périodes d'arrêt technique de la passe sont
traduites en alternance de périodes d'arrêt technique, pendant lesquelles la
passe est fermée alors que le niveau de la mer permettrait son ouverture, et des
périodes d'arrêt normal liées au fonctionnement. Pour ces dernières en effet, en
fonctionnement normal la passe aurait été fermée car le niveau de la mer s'approche à moins de 30 cm du niveau de la Vilaine ce qui
aurait déclenché la fermeture de la vanne amont pour éviter les intrusions d'eau
salée (Figure \ref{detail_fonct_passe_2} en annexe).

En dehors des périodes d'arrêt et lorsque les coefficients de marée dépassent
70, la passe alterne entre des périodes où elle est fermée à marée haute, des
périodes de régulation à marée montante et descendante, et où le niveau de la
mer à basse mer descend en dessous de la cote de régulation de la vanne. La
chute aval augmente alors au delà du seuil de 50 cm auquel nous
considérons que la passe devient infranchissable (dysfonctionnement hydraulique) 
(Figure \ref{detail_fonct_passe_1} en annexe).


Lors des périodes d'étiages, deux moyens sont utilisés pour réduire le débit de
la passe. D'une part la fermeture du canal de débit d'appoint qui double
le débit dans le bassin aval de la passe, d'autre part l'arrêt de la passe
à basse mer car les migrations sont nulles lorsque la passe est en
dysfonctionnement hydraulique, et globalement les passages sont faibles
lors des marées descendantes et à basse mer. Malgré la baisse de débit, nous
considérons que la passe reste attractive car l'exutoire des tuyaux du siphon se situe près de l'entrée aval de la passe. 
De plus, il n'est pas nécessaire de maintenir un débit d'attrait important pour
que les poissons trouvent la source principale de l'eau douce s'écoulant dans l'estuaire dont la salinité
est proche de l'eau de mer en absence de débit.



\subsection{Système de suivi vidéo numérique}

Avant leur sortie à l'amont de la passe, les poissons sont dirigés par un
système de grille vers un couloir équipé de vitres. Un caisson de rétroéclairage
permet de filmer les poissons en ombres chinoises. Le système d'enregistrement
se compose d'une caméra, d'un ordinateur pour l'enregistrement (Figure
\ref{photo:suivi_numerique}). Le système de comptage est basé sur un enregistrement numérique des passages de poissons réalisé à l’aide des logiciels SYSIPAP (Système de Surveillance Informatisée 
des Passes à Poissons). Ce système fonctionne en deux phases :

\begin{itemize}
\item la première est une phase d'enregistrement sur le site de séquences vidéo
numérisées et compressées d’une taille d’environ 10 Mo (logiciel WSEQ32, vers. 6.2),
\item la deuxième est un dépouillement des enregistrements en temps différé
(WPOIS32, vers. 5.2).
\end{itemize}

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{suivi_numerique.jpg}
\caption{Système de suivi vidéo numérique.
}
\label{photo:suivi_numerique}
\end{figure}

\subsubsection{Enregistrement vidéo}
Le logiciel d'acquisition de séquences d'images WSEQ32 (Image
\ref{image:wseq32}) comprend les fonctionnalités suivantes :
\begin{itemize}
\item	déclenchement d'alarme basée sur la détection de variations d'intensité
lumineuse,
\item	déclenchement d'enregistrement comprimé sur le disque dur d'un PC.
\end{itemize}
Les paramètres ajustables sont :
\begin{enumerate}
\item	le cycle de mesure,
\item   la taille, la sensibilité et le mode actif/inactif des cellules
composant l'écran, 
\item	le seuil de déclenchement de l'alarme,
\item	la temporisation de l’alarme,
\item	le nombre d’images enregistrées précédant la condition de déclenchement.
\end{enumerate}

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{wseq32.png}
\caption{Logiciel d’acquisition vidéo.
}
\label{image:wseq32}
\end{figure}

\subsubsection{Dépouillement vidéo}

Le logiciel de dépouillement WPOIS32 (Figure \ref{image:wpois32}) fonctionne sur Arzal de
manière manuelle, c'est-à-dire que la personne qui visionne les fichiers vidéo doit reconnaître
les différentes espèces et rentrer les effectifs correspondant à l’aide de l’interface "choix espèce".
Le résultat du dépouillement est un fichier texte comprenant la liste des événements enregistrés :
espèce, montée ou descente, numéro de l’image de sortie, date et heure, taille
en pixel et distance du poisson à la vitre.

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{wpois32.png}
\caption{Logiciel de dépouillement vidéo.
}
\label{image:wpois32}
\end{figure}

\subsubsection{Echappement au dispositif de franchissement}

Le barrage d’Arzal, par son faible dénivelé, reste franchissable par les volets,
par l’écluse, voire par les vannes wagons lorsque le dénivelé est faible. Mais
il ne l’est que dans certaines conditions et sur de courtes périodes.

La gestion du barrage, liée aux contraintes hydrauliques amont (débit à évacuer) et aval (marée), 
a une grande incidence sur la franchissabilité du barrage.
Le débit du fleuve peut être évacué par des vannes wagons ou
par des clapets flottants (volets) en surverse.
En règle générale, la plus grande part du débit est évacuée de jour, par l’intermédiaire des vannes. 
L’ouverture des volets la nuit permet de s’affranchir de la surveillance des vannes, 
les volets flottants empêchant mécaniquement la remontée de l’eau de mer dans le
plan d’eau amont. En période printanière quand les débits sont faibles et que
les volets fonctionnent, des bancs de mulets peuvent tenter de les franchir. Ce
franchissement peut concerner plusieurs milliers d'individus dans la demie heure
où les volets sont franchissables.

Entre 2013 et 2020 nous avons observé grâce à un sonar multifaisceaux (DIDSON)
des passages de lamproies marines sous les vannes lorsque les vitesses de courant ne sont pas élevées. Les effectifs recalculés peuvent être conséquents.
Lorsque la marée monte jusqu’au niveau des volets, il arrive un moment où ils sont franchissables par des espèces
ayant une bonne capacité de nage. \textcolor{orange_EV}{Les chiffres donnés pour
l’évaluation des stocks de migrateurs doivent donc être considérés comme un minimum}.

\section{Résultats}
\subsection{Fonctionnement de la passe à bassins}
\paragraph{Résumé du fonctionnement.}

Le fonctionnement de la passe en 2022 a été plutôt bon. Il y a eu des arrêts en
janvier et février lors des crues. La passe est en effet fermée
en débit de crue pour empêcher la descente d'objets flottants et car la baisse
de la ligne d'eau amont limite fortement les débits évacués. En pratique, la
passe est très peu attractive en conditions de crue. En février il y a eu une
intervention sur les capteurs de la vanne aval. En 2022, les débits sont restés soutenus et la passe n'est pas passée en
mode étiage, il n'y a pas eu non plus de mise en place de battardage du débit
d'appoint.
Plusieurs interventions techniques ont eu lieu avec un problème de
fonctionnement de la vanne intermédiaire le 26 avril, qui ont finalement été
réglés en octobre novembre avec le remplacement des joints.

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/fonctionnement_passe.png}
\caption{Fonctionnement de la passe en \Sexpr{CY}, niveaux Vilaine, mer, sas
(dernier bassin en aval de la passe), et niveaux de la vanne aval. Chaque point correspond aux niveaux
enregistrés lors d'une période de 10 minutes. Les données ont été corrigées des
valeurs abérrantes. Les données concernant le codeur du vérin de la vanne aval
sont manquantes en début de saison.}
\label{figure_fonctionnement_passe}
\end{figure}

\paragraph{Calculs du fonctionnement et des débits la passe à bassins.}
Les niveaux observés pour la ligne d'eau et les cotes de vannes de la passe
à bassins sont illustrés en figure \ref{figure_fonctionnement_passe}. A
partir de ces niveaux, dont le détail est présenté en annexe (Figures
\ref{detail_fonct_passe_2} et \ref{detail_fonct_passe_1}), le fonctionnement
de la passe est calculé par période de 10 minutes (Figure \ref{report_df_annee}
en annexe).

En figure \ref{report_df_fct_2003_2022}, l'analyse des durées mensuelles
cumulées de chaque type de fonctionnement permet de se donner une idée des
périodes auxquelles la passe a été arrêtée (en orange
\textcolor{orange_EV}{\rule[-0.2mm]{3mm}{2mm}}) - arrêt lors des crues), mais également des périodes où elle a fonctionné de manière plus limitée, 
par exemple le passage en mode étiage de 2016 à 2019 se traduit par une  
augmentation de la durée des dysfonctionnements
(en orange \textcolor{orange_EV}{\rule[-0.2mm]{3mm}{2mm}}) ou par des arrêts
nocturnes (en jaune \textcolor{jaune_EV}{\rule[-0.2mm]{3mm}{2mm}}). Les mêmes
graphiques sont présentés pour la période 2003-2011 (Figure
\ref{report_df_2003_2022}) en mettant juste en avant les périodes où la passe est fonctionnelle
(en bleu \textcolor{bleu_EV}{\rule[-0.2mm]{3mm}{2mm}}) et les périodes où elle
ne l'est pas (en orange \textcolor{orange_EV}{\rule[-0.2mm]{3mm}{2mm}}).

Les débits de la passe calculés par l'automate du barrage 
(Figure \ref{debit_passe_mesure} en annexe) sont aussi recalculés en prenant en
compte des corrections de valeurs abérrantes et du coefficient de noyage de la vanne aval
(Figure \ref{debit_passe_calcul} en annexe, Figure \ref{debit_passe_comp}).

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/debit_passe_comp.png}
\caption{Débits de la passe en \Sexpr{CY}. Débits produits par l'automate du
barrage et recalculés en prenant compte du noyage de la chute à l'aval et des
valeurs abérrantes de niveaux.}
\label{debit_passe_comp}
\end{figure}

%
\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/report_df_fct_2003_2022.png}
\caption{Fonctionnement de la passe de 2003 à 2022, avec les détails par type
de fonctionnement.}
\label{report_df_fct_2003_2022}
\end{figure}%
%

%
\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/report_df_2003_2022.png}
\caption{Fonctionnement de la passe de 2003 à 2022.}
\label{report_df_2003_2022}
\end{figure}%
%

\paragraph{Fonctionnement du dispositif de comptage.}

Le dispositif de comptage 
a été mis en service le
\Sexpr{vvv$ref_dc$date_debut} et arrêté le
\Sexpr{vvv$ref_dc$date_fin} (Figure \ref{report_dc_2022}).
Les arrêts techniques pendant la période de suivi sont relativement rares
(Figure \ref{report_dc_1998_2022}). 
La caméra a été déplacée lors
du lavage des vitres ce qui entraine un décalage de l'image avec perte de la
partie basse en Juillet (voir Figure \ref{report_dc_2022}). Les néons de la
passe ont été remplacés par des néons à leds mais l'intervention a duré moins
d'une journée (en août). La période d'arrêt du DC en octobre est liée à un défaut de
la RAM de l'ordinateur qui a du être remplacée.

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/report_dc_2022.png} 
\caption{Bilan du fonctionnement du dispositif de comptage en \Sexpr{CY}.}
\label{report_dc_2022}
\end{figure}

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/report_dc_1998_2022.png} 
\caption{Bilan du fonctionnement du dispositif de comptage de 1998 à 2022.}
\label{report_dc_1998_2022}
\end{figure}

<<fonctions_passe, echo=FALSE, eval=TRUE ,include=FALSE>>=
#' @title pastequery create the query to siva using the arguments passed in table data
#' @description This function is called from within pmap to prepare the query for each line of the data frame
#' @param table table containing rows name, tag, start, end
#' @param name the name of the table to be used later in code
#' @param tag the tag in SIVA, if not used put zero
#' @param start first horodate to fetch data
#' @param end last horodate to fetch data
#' @return A query for each line of the table
#' @examples 
#' @rdname pastequery
#' @export 
pastequery <- function(table,name,tag,start,end){
  if (tag==0){
    query <- paste("SELECT HoroDate,valeur FROM",table,"WHERE HoroDate >=",start,
        "AND HoroDate < ",end)
  } else {
    query <- paste("SELECT HoroDate, valeur FROM",table,"WHERE HoroDate >=",start,
        "AND HoroDate < ",end,
        "AND tag=",tag)
  }
  return(query)	
}


#' @title Function to get data from an open connexion con to SIVA
#' @description This function will fetch data for each row of the table .df
#' @param con An active connexion to SIVA 
#' @param .df A data frame or tibble containing fields table, name, tag, by
#' @param start An horodate for the beginning date
#' @param end An horodate for the ending date
#' @return df with a column appended containting a list of data.frame fetched from the database
#' @details DETAILS
#' @examples 
#' \dontrun{
#' if(interactive()){
#'  if (load_packageNamespace("dplyr", quietly = TRUE){
#'  con <-dbConnect(RMySQL::MySQL(), dbname = "archive_IAV", username = decrypt_string(umysql,pois),
#'		password = decrypt_string(pwdmysql,pois),host=decrypt_string(hostmysql,pois))
#' df<- dplyr::tribble(
#'		~name, ~table, ~tag,
#'		"niveau_mer_passe","b_passeapoisson_niveaumer",   0,
#'		"niveau_sas_passe","b_passeapoisson_niveausas",   0)
#'  }
#' start <-"'2018-01-01 00:00:00'"
#' end <-"'2018-01-02 00:00:00'"
#' res <- getdata(con,.df=df,start,end)
#' }
#' }
#' @rdname getdata
#' @export 
getdata <- function(con,.df,start,end){
  .df$start <- start
  .df$end <- end
  .df <- .df %>% mutate(.,"query"=pmap_chr(.,.f= pastequery))
  .df <- .df %>% add_column(result=list(rep(list(),nrow(.df))))
  for (i in 1:nrow(.df)){
    cat("query for ",.df$table[i],"\n")
    rs <- dbSendQuery(conn=con,statement=.df$query[i])
    .df$result[i][[1]] <- tryCatch(dbFetch(rs, n = -1) ,
        finally=dbClearResult(rs))
    cat("nrow for ",.df$table[i]," :",nrow(.df$result[i][[1]]),"\n")
  }
  dbDisconnect(con)
  return(.df)	
}
#' @title Calcul du fonctionnement de la passe d'Arzal
#' @description Par défaut la fonction utilise les niveaux mer et Vilaine barrage puis les niveaux passe 
#' quand ces derniers sont manquants. Calcule les périodes continues avec les mêmes paramètres pour per_tar_code
#' à l'aide de la fonction rle
#' @param dat jeu de données contenant les colonnes c("niveau_vilaine_passe","niveau_mer_passe","niveau_vilaine_barrage","niveau_mer_barrage","niveau_sas_passe",
#'			"hauteur_vanne_vilaine","hauteur_vanne_mer")
#' @param per_dis_identifiant Identifiant du dispositif de franchissement, Default: 1
#' @param vvv Liste contenant les éléments numériques pour le rapport
#' @return list with dat=data frame avec les données corrigées et les fonctionnements de la passe (types d'arrêts),
#' t_periodefonctionnement_dis le tableau à réimporter dans stacomi contenant les périodes de fonctionnement des dispositifs
#' @details 
#' @examples 
#' \dontrun{
#' if(interactive()){
#'  #dat <- data_DF_init
#'  #calc_fonct_pass(dat)
#'  }
#' }
#' @rdname calc_fonct_pass

calc_fonct_pass <- function(dat, per_dis_identifiant=1, vvv){
  
  # checks -------------------------------------------
  
  cols <- c("time","niveau_vilaine_passe","niveau_mer_passe","niveau_vilaine_barrage","niveau_mer_barrage","niveau_sas_passe",
      "hauteur_vanne_vilaine","hauteur_vanne_mer")
  test_column_present <- cols %in% colnames(dat)
  if (!all(test_column_present)) stop("columns",paste(cols[!test_column_present], collapse=","),"manquantes") 
  # teste que les colonnes sont ordonnées
  stopifnot(sort(dat$time)==dat$time)
  vvv$fonct_pass <- list()
  cat(nrow(dat), 
      "lignes dans le fichier d'entrée \n")
  vvv$fonct_pass$nb_lignes <- nrow(dat)
  
  # niveau mer barrage ..................
  
  na_niveau_mer_barrage <- is.na(dat$niveau_mer_barrage)
  if (sum(na_niveau_mer_barrage)>0) cat(sum(na_niveau_mer_barrage), "lignes avec valeurs manquantes pour niveau mer \n")
  na_niveau_mer_passe <-  is.na(dat$niveau_mer_passe)
  dat$niveau_mer_barrage[na_niveau_mer_barrage & !na_niveau_mer_passe] <- 
      dat$niveau_mer_passe[na_niveau_mer_barrage & !na_niveau_mer_passe]
  if (sum(na_niveau_mer_barrage & !na_niveau_mer_passe)>0) cat(
        sum(na_niveau_mer_barrage & !na_niveau_mer_passe),
        "lignes niveau mer barrage remplacées par niveau mer passe \n")	
  vvv$fonct_pass$niveau_mer_barrage_manquant_rempl <- sum(na_niveau_mer_barrage & !na_niveau_mer_passe)
  na_niveau_mer_barrage <- is.na(dat$niveau_mer_barrage)  # prise en compte des valeurs remplacées
  vvv$fonct_pass$niveau_mer_manquant_final <- sum(na_niveau_mer_barrage)
  
  # niveau vilaine barrage ..................
  
  trop_bas_niveau_vilaine <- dat$niveau_vilaine_barrage< -0.5 & !is.na(dat$niveau_vilaine_barrage)
  dat$niveau_vilaine_barrage[trop_bas_niveau_vilaine] <- NA
  vvv$fonct_pass$trop_bas_niveau_vilaine <- sum(trop_bas_niveau_vilaine)
  na_niveau_vilaine_barrage <- is.na(dat$niveau_vilaine_barrage)
  if (sum(na_niveau_vilaine_barrage)>0) cat(sum(na_niveau_vilaine_barrage), "lignes avec valeurs manquantes pour niveau Vilaine \n")
  na_niveau_vilaine_passe <-  is.na(dat$niveau_vilaine_passe)
  dat$niveau_vilaine_barrage[na_niveau_vilaine_barrage & !na_niveau_vilaine_passe &  dat$niveau_vilaine_passe>= -0.5] <- 
      dat$niveau_vilaine_passe[na_niveau_vilaine_barrage & !na_niveau_vilaine_passe & dat$niveau_vilaine_passe>= -0.5]
  if (sum(na_niveau_vilaine_barrage & !na_niveau_vilaine_passe  &  dat$niveau_vilaine_passe>= -0.5)>0) cat(
        sum(na_niveau_vilaine_barrage & !na_niveau_vilaine_passe  &  dat$niveau_vilaine_passe>= -0.5),
        "lignes niveau Vilaine barrage remplacées par niveau Vilaine passe \n")	
  vvv$fonct_pass$niveau_vilaine_barrage_manquant_rempl <- sum(na_niveau_vilaine_barrage & !na_niveau_vilaine_passe)
  na_niveau_vilaine_barrage <- is.na(dat$niveau_vilaine_barrage) # prise en compte des valeurs remplacées
  vvv$fonct_pass$niveau_vilaine_manquant_final <- sum(na_niveau_vilaine_barrage)
  
  
  
  # Fermeture de la vanne amont ...........................
  
  # pb niveau mer trop faible ..................
  
  pb_niveau_mer <- !na_niveau_mer_barrage & dat$niveau_mer_barrage< -3.5
  if (sum(pb_niveau_mer)>0) cat(sum(pb_niveau_mer),"lignes avec niveau mer < -3.5  => corrigées \n")
  dat[pb_niveau_mer,"niveau_mer_barrage"] <- -3.5
  vvv$fonct_pass$pb_niveau_mer_inf_3.5 <- sum(pb_niveau_mer)
  # pb niveau sas passe trop faible ou fort ..................
  
  pb_niveau_sas_passe_inf_m1 <- dat$niveau_sas_passe < -1   & !is.na(dat$niveau_sas_passe)
  pb_niveau_sas_passe_sup_2.5 <- dat$niveau_sas_passe > 2.5 & !is.na(dat$niveau_sas_passe)
  if (sum(pb_niveau_sas_passe_inf_m1)>0) cat(sum(pb_niveau_sas_passe_inf_m1),"lignes avec niveau SAS < -1 => corrigées \n")
  if (sum(pb_niveau_sas_passe_sup_2.5)>0) cat(sum(pb_niveau_sas_passe_sup_2.5),"lignes avec niveau SAS > 2.5  => corrigées \n")
  dat$niveau_sas_passe[pb_niveau_sas_passe_inf_m1] <- -1
  dat$niveau_sas_passe[pb_niveau_sas_passe_sup_2.5] <- 2.5
  vvv$fonct_pass$pb_niveau_sas <- sum(pb_niveau_sas_passe_inf_m1,pb_niveau_sas_passe_sup_2.5)
  # pb hauteur vanne mer trop faible ou fort ..................	
  
  pb_hauteur_vanne_mer_inf_m1.72 <- dat$hauteur_vanne_mer< -1.72   & !is.na(dat$hauteur_vanne_mer)
  pb_hauteur_vanne_mer_sup_2.08 <- dat$hauteur_vanne_mer>2.08 & !is.na(dat$hauteur_vanne_mer)
  if (sum(pb_hauteur_vanne_mer_inf_m1.72)>0) cat(sum(pb_hauteur_vanne_mer_inf_m1.72),"lignes avec niveau vanne mer < -1.72  => corrigées \n")
  if (sum(pb_hauteur_vanne_mer_sup_2.08)>0) cat(sum(pb_hauteur_vanne_mer_sup_2.08),"lignes avec niveau vanne mer  > 2.08  => corrigées \n")
  
  dat$hauteur_vanne_mer[pb_hauteur_vanne_mer_sup_2.08] <- 2.08
  dat$hauteur_vanne_mer[pb_hauteur_vanne_mer_inf_m1.72] <- 1.72
  vvv$fonct_pass$pb_hauteur_vanne_mer <- sum(pb_hauteur_vanne_mer_sup_2.08,pb_hauteur_vanne_mer_inf_m1.72)
  # Initialisation des variables -----------------------------------
  
  dat$delta_vilaine_mer <- dat$niveau_vilaine_barrage - dat$niveau_mer_barrage
  dat$delta_sas_mer <- dat$niveau_sas_passe - dat$niveau_mer_barrage
  dat$per_etat_fonctionnement <- as.integer(NA)
  dat$per_tar_code <- as.integer(NA)
  
  # CAS 1 - si on a pas d'information sur le Niveau Vilaine-----------------
  
  dat[is.na(dat$delta_vilaine_mer) | is.na(dat$hauteur_vanne_vilaine) | is.na(dat$delta_sas_mer) , 
      "per_tar_code"] <- 5
  dat[is.na(dat$delta_vilaine_mer) | is.na(dat$hauteur_vanne_vilaine) | is.na(dat$delta_sas_mer) , 
      "per_etat_fonctionnement"] <- TRUE # temporary
  
  cat(sum(is.na(dat$delta_vilaine_mer) | is.na(dat$hauteur_vanne_vilaine) | is.na(dat$delta_sas_mer)), 
      "lignes avec valeurs manquantes pour le calcul du fonctionnement de la passe \n")
  vvv$fonct_pass$pb_na <- sum(is.na(dat$delta_vilaine_mer) | is.na(dat$hauteur_vanne_vilaine) | is.na(dat$delta_sas_mer))
  
  # CAS 2 quand le delta entre la Vilaine et la mer est de moins de 0.3, la vanne amont est fermée, la passe est fermée
  # Arrêt du dispositif lié au fonctionnement normal du dispositif
  
  dat[dat$delta_vilaine_mer<0.3 & dat$hauteur_vanne_vilaine==-0.2 & is.na(dat$per_etat_fonctionnement), 
      "per_tar_code"] <- 2
  dat[dat$delta_vilaine_mer<0.3 & dat$hauteur_vanne_vilaine==-0.2 & is.na(dat$per_etat_fonctionnement), 
      "per_etat_fonctionnement"] <- FALSE
  
  # CAS 3 la vanne Vilaine est fermée, la passe est fermée mais c'est pas pour une raison de maintenance
  # La vanne aval ou la vanne amont peuvent être fermées
  
  dat[dat$hauteur_vanne_vilaine==-0.2 & is.na(dat$per_etat_fonctionnement), 
      "per_tar_code"] <- 3
  dat[dat$hauteur_vanne_vilaine==-0.2 & is.na(dat$per_etat_fonctionnement), 
      "per_etat_fonctionnement"] <- FALSE
  
  dat[dat$hauteur_vanne_mer==1.72 & is.na(dat$per_etat_fonctionnement), 
      "per_tar_code"] <- 3
  dat[dat$hauteur_vanne_mer==1.72 & is.na(dat$per_etat_fonctionnement), 
      "per_etat_fonctionnement"] <- FALSE
  
  
  # CAS 4 la passe est ouverte mais la chute aval est trop forte
  
  dat[dat$delta_sas_mer>0.5 & is.na(dat$per_etat_fonctionnement), 
      "per_tar_code"] <- 4
  dat[dat$delta_sas_mer>0.5 & is.na(dat$per_etat_fonctionnement), 
      "per_etat_fonctionnement"] <- FALSE
  
  # CAS 5 tous les autres cas la passe fonctionne
  
  dat[is.na(dat$per_etat_fonctionnement) , 
      "per_tar_code"] <- 1
  dat[is.na(dat$per_etat_fonctionnement) , 
      "per_etat_fonctionnement"] <- TRUE
  
  # finally reset NA to missing values
  
  dat[is.na(dat$delta_vilaine_mer) | is.na(dat$hauteur_vanne_vilaine) | is.na(dat$delta_sas_mer) , 
      "per_etat_fonctionnement"] <- NA # temporary
  
  vvv$fonct_pass$table_etat_fonct <- table(dat$per_tar_code)
  
  rle_per_tar_code <- rle(dat$per_tar_code) # run length encoding gives consecutive values
  index <- head(cumsum(rle(dat$per_tar_code)$lengths)+1,-1)  # remove last with head
  t_periodefonctdispositif_per <- 
      data.frame("per_dis_identifiant" = rep(per_dis_identifiant,length(index)-1),
          "per_date_debut"= 	dat$time[index[-length(index)]],
          "per_date_fin" = dat$time[index[-1]],
          "per_commentaires" = "fonct calcul",
          "per_etat_fonctionnement" = dat$per_etat_fonctionnement[index[-length(index)]],
          "per_tar_code" = dat$per_tar_code[index[-length(index)]])
  cat("Creation de t_periodefonctdispositif_per","nb lignes= ",nrow(t_periodefonctdispositif_per),"\n")
  vvv$fonct_pass$nb_lignes_t_periodefonct <- nrow(t_periodefonctdispositif_per)
  vvv <<- vvv # retroune le résultat de la liste vvv dans l'environnement principal
  return(list(dat=dat,t_periodefonctdispositif_per=t_periodefonctdispositif_per))
} # end function calc_fonc_pass

#' @title Calcul du débit de la passe
#' @description Calcule le débit de la passe à partir des types de fonctionnement du DF et du coefficient de 
#' noyage de la vanne aval
#' @param list_fonct_pass Une liste contenant un data.frame dat détaillant 
#' le foncionnement de la passe par pas de temps de 10 minutes (voir fonction calc_fonct_passe) 
#' @return list_fonct_pass avec calcul du débit dans la passe
#' @examples 
#' \dontrun{
#' if(interactive()){
#'  #calc_fonct_pass(ll)
#'  }
#' }
#' @rdname calcul_debit_passe
#' @export
calc_debit_passe <- function(list_fonct_pass, vvv){
  ###########################
  # Calcul de debit sur la passe
  ###########################
  dat <- ll$dat
  dat$delta_sas_vanne=dat$niveau_sas_passe-dat$hauteur_vanne_mer
  
  ################################################
  # deversoir denoye si vanne mer > niveau mer
  ################################################
  
  reindex <- (dat$hauteur_vanne_mer>dat$niveau_mer_passe)&
      (dat$per_tar_code==1|dat$per_tar_code==4)
  reindex[is.na(reindex)]=FALSE
  dat$debit_passe_recalcule <- NA
  dat$debit_passe_recalcule[reindex]=0.4*1.5*dat$delta_sas_vanne[reindex]^1.5*sqrt(2*9.81)
  ## not run =commentaire ### 0.3 coeff de debit /# 1.5 largeur de la vanne aval
  
  ################################################
  # deversoir noye
  ################################################
  ## not run =commentaire ### deltasasmer>1/10 *deltasasvanne  (hauteur d'eau sur la vanne <3 m pour 30 cm <1 m pour 10 cm
  ## not run =commentaire ###coeffnoyage<0.9
  reindex1 <- (dat$hauteur_vanne_mer<dat$niveau_mer_passe)&(dat$per_tar_code==1|dat$per_tar_code==4)
  reindex1[is.na(reindex1)] <- FALSE
  dat$coeff_noyage <- (dat$delta_sas_vanne-dat$delta_sas_mer)/dat$delta_sas_vanne
  dat$coeff_debit <- (1-dat$coeff_noyage^1.5)^0.385
  dat$debit_passe_recalcule <- NA
  dat$debit_passe_recalcule[reindex1] <- 
      dat$coeff_debit[reindex1]*0.4*1.5*dat$delta_sas_vanne[reindex1]^1.5*sqrt(2*9.81)
  test_coeff_noyage<-dat$coeff_noyage[reindex1]
  ## not run =commentaire ### la formule fonctionne normalement pour un coefficient de noyage limite
  cat(paste(
          "La formule de calcul de debit fonctionne normalement pour un coefficient de noyage limite",
          "il existe ",
          length(test_coeff_noyage[test_coeff_noyage>0.9]),
          "occurences de coeff > 0.9 sur un total de",
          length(test_coeff_noyage),
          "\n"))
  vvv$debit_passe$coeff_noyage_sup_0.9 <- length(test_coeff_noyage[test_coeff_noyage>0.9])
  vvv <<-vvv
  ################################################
  # passe fermee
  ################################################
  dat$debit_passe_recalcule[dat$per_tar_code==2|dat$per_tar_code==3]=0
  ll$dat <- dat
  return(ll)
}

#' @title Barplot des temps de fonctionnement du DF par type
#' @description retourne un ggplot
#' @param t_periodefonctdispositif_per le tableau des fonctionnements du DF, contenu dans ll la liste 
#' contenant à la fois les données par 10 min et les données au format stacomi (t_periodefonctionnement_per)
#' avec une date de début une date de fin et un changement à chaque étape.
#' @return Un graphique ggplot
#' @examples 
#' \dontrun{
#' if(interactive()){
#'  #graph_DF(ll$t_periodefonctdispositif_per)
#'  }
#' }
#' @rdname graph_DF
#' @export 
graph_DF=function(t_periodefonctdispositif_per){
  t_periodefonctdispositif_per$tempsdebut <- 
      strptime(t_periodefonctdispositif_per$per_date_debut, "%Y-%m-%d %H:%M:%S")
  t_periodefonctdispositif_per$tempsfin <- 
      strptime(t_periodefonctdispositif_per$per_date_fin, "%Y-%m-%d %H:%M:%S")
  t_periodefonctdispositif_per$sumduree <-
      as.numeric(difftime(t_periodefonctdispositif_per$tempsfin,	t_periodefonctdispositif_per$tempsdebut,units = "hours"))
  t_periodefonctdispositif_per$mois <- 
      strftime(t_periodefonctdispositif_per$tempsdebut,"%m")
  annee <- 
      strftime(t_periodefonctdispositif_per$tempsdebut[1],"%Y")
  t_periodefonctdispositif_per$per_tar_code <- 
      as.factor(t_periodefonctdispositif_per$per_tar_code)
  t_periodefonctdispositif_per <- 
      t_periodefonctdispositif_per[order(t_periodefonctdispositif_per$per_tar_code),]
  
  g<-ggplot(t_periodefonctdispositif_per)
  g <- g+geom_bar(aes(x=mois,y=sumduree,fill=per_tar_code),stat="identity",position="stack")+
      scale_fill_manual(values=c(bleu_EV,
              turquoise_EV,
              orange_EV,
              jaune_EV,
              "grey"
          ), 
          name="type d'arrêt",
          breaks=c("1", "2", "3","4","5"),
          labels=c("Fonc normal","Arr ponctuel",
              "Arr maint","Dysfonc","Non connu"))+theme_bw()+ylab("temps en heures")
  
  return(g)	
  
}

#' @title Plot avec lignes et indications du fonctionnement du DF
#' @description retourne un ggplot
#' @param data_DF le tableau des niveaux du df
#' avec une date de début une date de fin et un changement à chaque étape.
#' @param from date to start, character or date
#' @param to date to finish
#' @return Un graphique ggplot
#' @examples 
#' \dontrun{
#' if(interactive()){
#'  #graph_DF_detail(ll$dat)
#'  }
#' }
#' @rdname graph_DF_detail
#' @export 
graph_DF_detail=function(data_DF, from, to){
  
  if (missing(from)) {
    from <- data_DF$time[1]
    cat("from is missing, defaulting to fist horodate")
  } 
  if (typeof(from)=="character" ){
    from <- parse_date_time(from, orders = c("dmy", "ymd"))
    cat("from parsed to ",  strftime(from, "%d-%m-%Y "))
  }
  if (missing(to)){
    to <- from + as.difftime(1, unit="weeks")	
    cat("to is missing, defaulting to one week")
  }
  if (typeof(to)=="character" ){
    to <- parse_date_time(to, orders = c("dmy", "ymd"))
    cat("to parsed to ", strftime(to, "%d-%m-%Y"))
  }
  data_DFw <- data_DF %>% filter(time<to & time> from)
  
  data_DFw$per_tar_code <- as.factor(data_DFw$per_tar_code)	
  
  g <- ggplot(data_DFw) +
      geom_line(aes(x=time,y=niveau_mer_barrage),col=marron, lty=1) +
      geom_line(aes(x=time,y=niveau_vilaine_barrage),col=bleu_EV, lty=4) +
      geom_line(aes(x=time,y=niveau_sas_passe),col="mediumslateblue") +
      geom_line(aes(x=time,y=hauteur_vanne_mer),col="purple", lty=3) +
      geom_line(aes(x=time,y=hauteur_vanne_vilaine),col="darkgoldenrod", lty=1) +
      geom_rect(aes(xmin=time,xmax=time+as.difftime(10,units = "mins"),ymin=-3.5,ymax=-3, fill=per_tar_code),alpha=0.8) +
      theme_bw() +
      scale_fill_manual(values=c("#17364E","moccasin","#765223","#B68B52","grey"),					
          name=iconv("type d'arrêt","UTF8"),
          breaks=c("1", "2", "3", "4", "5"),
          labels=c("Fonc normal","Arr ponctuel",
              "Arr maint","Dysfonc","Non connu"))+
      ylab("Niveau en m")
  
  
  return(g)	
  
}


@


<<chargement_donnees_barrage,echo=FALSE,eval=FALSE,include=FALSE>>=
library(RMySQL)
library(getPass)
library(safer)
library(tidyverse)

# load password used to encrypt strings 
pois <- getPass(msg="Main password")

#dbListTables(con);dbListTables(con)[grep("sal",dbListTables(con))]


# Why do I need to include name ? 
# I need to pass all arguments from table to the function otherwise crashes ...


con <-dbConnect(RMySQL::MySQL(), dbname = "archive_IAV", username = decrypt_string(umysql,pois),
    password = decrypt_string(pwdmysql,pois),host=decrypt_string(hostmysql,pois))
df<- tribble(
    ~name, ~table, ~tag,
    "niveau_mer_passe","b_passeapoisson_niveaumer",   0,
    "niveau_sas_passe","b_passeapoisson_niveausas",   0,
    "niveau_vilaine_passe","b_passeapoisson_niveauvilaine", 0,
    "volume_cumule_passe","b_barrage_debit",   2523,
    "niveau_mer_barrage","b_barrage_niveau", 2508,
    "niveau_vilaine_barrage","b_barrage_niveau", 2507,
    "hauteur_vanne_mer","b_passeapoisson_hauteurvannemer", 0,
    "hauteur_vanne_vilaine","b_passeapoisson_hauteurvannevilaine", 0,
    "debit_passe","b_barrage_debit", 2523,       # volume jour passe
    "temperature_corde1_cran","b_pont_de_cran_vitesse",1909,
    "temperature_corde2_cran","b_pont_de_cran_vitesse",1910,		
    "temperature_externe_barrage","b_barrage_temperature",2560,	#temperature exterieure
    "debit_pont_de_cran","b_pont_de_cran_debit",1900,
    "debit_vilaine_estime","b_barrage_debit", 2515, 
)
start <-str_c("'",CY,"-01-01 00:00:00'")
end <-str_c("'",CY+1,"-01-01 00:00:00'")
res <- getdata(con,.df=df,start,end)

save(res, file=file.path(datawd,CY,"res.Rdata"))

@





<<calcul_fonctionnement_passe, echo=FALSE, eval=FALSE, include=FALSE>>=


# post traitement 
load(file.path(datawd,CY,"res.Rdata"))
library(tidyverse)


# le fichier est structuré comme suit --------------------------
#Classes 'tbl_df', 'tbl' and 'data.frame':	12 obs. of  7 variables:
#		$ name  : chr  "niveau_mer_passe" "niveau_sas_passe" "niveau_vilaine_passe" "volume_cumule_passe" ...
#$ table : chr  "b_passeapoisson_niveaumer" "b_passeapoisson_niveausas" "b_passeapoisson_niveauvilaine" "b_barrage_debit" ...
#$ tag   : num  0 0 0 2523 2508 ...
#$ start : chr  "'2018-01-01 00:00:00'" "'2018-01-01 00:00:00'" "'2018-01-01 00:00:00'" "'2018-01-01 00:00:00'" ...
#$ end   : chr  "'2019-01-01 00:00:00'" "'2019-01-01 00:00:00'" "'2019-01-01 00:00:00'" "'2019-01-01 00:00:00'" ...
#$ query : chr  "SELECT HoroDate,valeur FROM b_passeapoisson_niveaumer WHERE HoroDate >= '2018-01-01 00:00:00' AND HoroDate <  '"| __truncated__ "SELECT HoroDate,valeur FROM b_passeapoisson_niveausas WHERE HoroDate >= '2018-01-01 00:00:00' AND HoroDate <  '"| __truncated__ "SELECT HoroDate,valeur FROM b_passeapoisson_niveauvilaine WHERE HoroDate >= '2018-01-01 00:00:00' AND HoroDate "| __truncated__ "SELECT HoroDate, valeur FROM b_barrage_debit WHERE HoroDate >= '2018-01-01 00:00:00' AND HoroDate <  '2019-01-0"| __truncated__ ...
#$ result:List of 12
#..$ :'data.frame':	51320 obs. of  2 variables:
#		.. ..$ HoroDate: chr  "2018-01-01 00:00:00" "2018-01-01 00:10:00" "2018-01-01 00:20:00" "2018-01-01 00:30:00" ...
#.. ..$ valeur  : num  -0.137 0.21 0.434 0.548 0.804 ...
#..$ :'data.frame':	51321 obs. of  2 variables:
#		.. ..$ HoroDate: chr  "2018-01-01 00:00:00" "2018-01-01 00:10:00" "2018-01-01 00:20:00" "2018-01-01 00:30:00" ...
#.. ..$ valeur  : num  -0.434 -0.374 -0.255 -0.188 -0.121 -0.094 -0.008 0.049 0.086 0.122 ...

res1 <-
    res %>% # drop the columns I no longer need
    select(name,result)%>%
    unnest(col=c(result))

############################
# PB HEURES ARZAL
############################

# GMT is UTC, it blocks conversion to summer time, like the dam but with one hour delay
# I want the date in France time so I first convert to "Europe/Paris" and remove one hour to all dates
# This way the difference is zero in winter and one in summer like the dam

res1 <- res1 %>%
    mutate("time"=as.POSIXct(strptime(HoroDate,tz="GMT",format="%Y-%m-%d %H:%M:%S")))
attributes(res1$time)$tzone <- "Europe/Paris"
res1 <- res1 %>%
    mutate("time"=time-as.difftime(1, units = "hours"))		



# Check that all dates are rounded in SIVA
#stopifnot( sum(lubridate::round_date(res1$time,"10 mins")!=res1$time)==0)


data_DF_init <- res1 %>% select(name,time,valeur)%>%
    pivot_wider(names_from=name,values_from=valeur) %>%
    arrange(time)

# problèmes de codeur sur vanne aval ou le sas (pas possibel d'avoir 2.8 m de charge sur vanne aval)
data_DF_init[data_DF_init$hauteur_vanne_mer< -1  &
        !is.na(data_DF_init$hauteur_vanne_mer) &
        data_DF_init$niveau_sas_passe> 1.8 &
        !is.na(data_DF_init$niveau_sas_passe)
    ,"niveau_sas_passe"] <- 
    data_DF_init[data_DF_init$hauteur_vanne_mer< -1  &
            !is.na(data_DF_init$hauteur_vanne_mer) &
            !is.na(data_DF_init$niveau_sas_passe) &
            data_DF_init$niveau_sas_passe> 1.8 
        ,"niveau_mer_passe"]+0.3


ll <- calc_fonct_pass(dat = data_DF_init, vvv=vvv)
data_DF <- ll$dat
# SIVA 2023 (I deleted the vvv parm)
vvv$coeff_noyage_sup_0.9 <- ll$coeff_noyage_sup_0.9

png(filename=file.path(imgwd,CY,"fonctionnement_passe.png"),7,7,units="in",res=300)
plot(data_DF$time,
    data_DF$niveau_mer_passe,
    type="n", 
    col=turquoise_EV,
    cex=0.2,
    ylab="Niveau NGF (m)",
    xlab="mois")
points(data_DF$time,
    data_DF$hauteur_vanne_mer,pch=18,
    col=jaune_EV,
    cex=0.5) 
points(data_DF$time,
    data_DF$niveau_mer_passe,
    col=turquoise_EV,
    cex=0.2) 
points(data_DF$time,
    data_DF$niveau_sas_passe,
    col=orange_EV,
    cex=0.1)
points(data_DF$time,
    data_DF$niveau_vilaine_barrage,
    type="l",
    col=orange_EVf) 
legend("bottomleft",		
    legend=c("niveau mer","niveau sas","niveau Vilaine","niveau vanne mer"),
    col=c(turquoise_EV,orange_EV,orange_EVf,jaune_EV),
    pch=16)
dev.off()


save(ll,file=file.path(datawd,CY,"fonct_pass.Rdata"))
path <- file.path(datawd,CY,"t_periodefonctdispositif_per.csv")
write.table(ll$t_periodefonctdispositif_per,file=path,
    row.names=FALSE,col.names=FALSE,sep=";",quote=FALSE)
save(vvv,file=file.path(datawd,CY,"vvv.Rdata"))
@

<<calcul_debit_passe, echo=FALSE, eval=FALSE, include=FALSE>>=
#	liste ll avec dat, le dataframe des données corrigées, et t_periodefonctionnementdispositif_dis,
#   le fichier des périodes de fonctionnement
load(file=file.path(datawd,CY,"fonct_pass.Rdata"))	# ll

ll <- calc_debit_passe(ll,vvv)
data_DF <- ll$dat
# 2022 pb de codeur pour la vanne aval


png(filename=file.path(imgwd,CY,"detail_fonct_passe_1.png"),7,7,units="in",res=300)
graph_DF_detail(data_DF, from="08/04/2022")
dev.off()

png(filename=file.path(imgwd,CY,"detail_fonct_passe_2.png"),7,7,units="in",res=300)
graph_DF_detail(data_DF=data_DF, from="15-05-2022", to="19-05-2022")
dev.off()

##############################################################
# Graph des temps de fonctionnement
############################################################





annee <- strftime(as.POSIXlt(data_DF$time[1]),"%Y")
data_DF$tpsnum <- as.vector(unclass(data_DF$time))
data_DF$mois <- strftime(as.POSIXlt(data_DF$time),"%m")
data_DF$jour <- strftime(as.POSIXlt(data_DF$time), "%j") 
ledebut <- min(data_DF$time,na.rm=TRUE)
lafin <- max(data_DF$time,na.rm=TRUE)

lm1 <- lm(data_DF$debit_passe_recalcule~data_DF$delta_sas_vanne)
resdeb <- lm1$residuals
index <- !(is.na(data_DF$debit_passe_recalcule)|is.na(data_DF$delta_sas_vanne) )
data_DF$resdeb <- NA
data_DF$resdeb[index] <- resdeb 
png(filename=file.path(imgwd,CY,"debit_passe_calcul.png"),7,7,units="in",res=300)
plot(data_DF$time,
    data_DF$debit_passe_recalcule,
    xlab="mois",
    ylab="m3 par seconde",
    type="p",
    pch="*",
    #main=paste(
    #		iconv("Débit instantané de la passe à bassins recalculé en","UTF-8"),annee),
    cex=3/4)
dev.off()


png(filename=file.path(imgwd,CY,"debit_passe_mesure.png"),7,7,units="in",res=300)
plot(data_DF$time,
    data_DF$debit_passe,
    xlab="mois",
    ylab="m3 par seconde",
    type="p",
    pch="*",
    cex=3/4)
dev.off()
# graphique avec residus 

qp<-ggplot(data_DF) + geom_point(aes(x=time,debit_passe_recalcule,colour=resdeb))
print(qp)

################################################
#Calcul du debit instantane journalier
# 1 debit m3/s toutes les dix minutes * 600s (60*10) =debit en m3
################################################

#jour de l'annee
data_DF_jour <- data_DF %>% group_by(jour) %>% 
    summarise(debit_jour_recalcul = sum(debit_passe_recalcule*600),
        debit_jour_automate = sum(debit_passe*600))

debit_mois_recalcul<-tapply(data_DF$debit_passe_recalcule*600,list(as.factor(data_DF$mois)),sum,na.rm = TRUE)

barplot(debit_mois_recalcul)
barplot(data_DF_jour$debit_jour_recalcul)

# Ici on fait en sorte de n'avoir pas de jours manquants dans la séquence
# Pas sûr que ce soit nécessaire
#seqdate=strftime(as.POSIXlt(seq(from=ledebut,to=lafin,by="day")),"%d-%m")
seqdate=seq(from=ledebut,to=lafin,by="day")
#seqdate=seqdate[1:366]
table_jour <- data.frame("seqdate"=seqdate)
table_jour <- left_join(table_jour%>% mutate(jour=strftime(seqdate,"%j")), 
    data_DF_jour,
    by="jour")

# "graphique de synthese des deux debits sur l'annee
png(filename=file.path(imgwd,CY,"debit_passe_comp.png"),10,7,units="in",res=300)
plot(table_jour$seqdate,table_jour$debit_jour_automate,
    type="o",
    lty=1,
    col=c(turquoise_EVf),
    pch=1,
    ylab="débit journaliers (m3)",
    xlab="date",
    ylim=c(min(cbind(table_jour$debit_jour_recalcul,table_jour$debit_jour_automate), na.rm=TRUE),
        max(cbind(table_jour$debit_jour_recalcul,table_jour$debit_jour_automate), na.rm=TRUE)),
    main=paste("Débits de la passe en ", annee))
points(table_jour$seqdate,table_jour$debit_jour_recalcul,
    lty=1,
    type="o",
    pch=1,
    col=c(bleu_EV))
legend(x=seqdate[100],
    y=max(cbind(table_jour$debit_jour_recalcul,table_jour$debit_jour_automate)),
    legend= c("débit automate","débit recalcule","débit mini. biol.",
        "battardage"),
    lty=1,
    col=c(turquoise_EVf,bleu_EV,"red",orange_EV),
    cex = 1,
    lwd = 0.9)
abline(h=28000,col="red")
abline(h=145000,col=orange_EV)
abline(h=0,col="black")
dev.off()

path<-file.path(datawd,paste("debits_journaliers_passe_",annee,".csv",sep=""))
write.table(table_jour,file=path,
    row.names=FALSE,col.names=TRUE,sep=";",quote=FALSE)

paste(
    "sauvegarde de la table des debits journaliers \n",
    path,
    "\n" ,
    "Fin du programme de calcul du debit"
)

save(vvv , file=file.path(datawd,CY,"vvv.Rdata"))
table_jour
@
<<ecrit_fonc_passe, echo=FALSE, eval=FALSE, include=FALSE>>=
# Vérifier qu'il n'y a pas de données de fonctionnement dans la base de données
req<- new("RequeteDB")
req <- connect(req)
res <- dbGetQuery(req@connection,glue("SELECT * FROM iav.t_periodefonctdispositif_per 
            WHERE per_dis_identifiant=1
            AND extract(year from per_date_debut)={CY}") )
# si la requete 
if (nrow(res)!=0){
  cat('Attention il y a déjà des données dans la base')	
}
# ATTENTION ECRITURE EN BASE !!!!
con <- dbConnect(RPostgres::Postgres(), dbname="bd_contmig_nat_iav",host=host,port=5432,user=user, password=password)
load(file=file.path(datawd,CY,"fonct_pass.Rdata"))
DBI::dbExecute(con, "DROP TABLE IF EXISTS t_periodefonctdispositif_per_temp")

DBI::dbWriteTable(req@connection, "t_periodefonctdispositif_per_temp", ll$t_periodefonctdispositif_per,overwrite=TRUE)
# Il y a des valeurs nulles dans per_etat_fonctionnement, or il ne peut être nul, par défaut je mets TRUE
# Il y a une erreur 
DBI::dbExecute(req@connection, "DELETE FROM  t_periodefonctdispositif_per_temp where per_date_fin < per_date_debut")
DBI::dbExecute(req@connection, "INSERT INTO iav.t_periodefonctdispositif_per (
        per_dis_identifiant
        ,per_date_debut
        ,per_date_fin
        ,per_commentaires
        ,per_etat_fonctionnement
        ,per_tar_code
        ,per_org_code)
        SELECT per_dis_identifiant
        ,per_date_debut
        ,per_date_fin
        ,per_commentaires
        , coalesce(per_etat_fonctionnement,1)::boolean
        , per_tar_code
        ,'IAV' as per_org_code
        FROM t_periodefonctdispositif_per_temp") #2772

# PETITES CORRECTIONS SUR LES OVERLAPS.....

#SELECT * FROM iav.t_periodefonctdispositif_per WHERE per_date_debut > '2019-01-01 00:00:00' AND per_dis_identifiant =1
#
#SELECT * FROM t_periodefonctdispositif_per_temp WHERE per_date_debut > '2019-01-01 00:00:00' AND per_dis_identifiant =1
#
#-- recherche de doublons externes
#SELECT * FROM t_periodefonctdispositif_per_temp t JOIN iav.t_periodefonctdispositif_per p ON 
#(t.per_date_debut, t.per_date_fin) OVERLAPS (p.per_date_debut,p.per_date_fin)
#WHERE p.per_dis_identifiant=1; --0 rows
#--recherche de doublons internes
#SELECT * FROM t_periodefonctdispositif_per_temp t1 JOIN t_periodefonctdispositif_per_temp t2 ON 
#(t1.per_date_debut, t1.per_date_fin) OVERLAPS (t2.per_date_debut,t2.per_date_fin)
#WHERE t1.per_date_debut!=t2.per_date_debut;
#
#
#DELETE FROM t_periodefonctdispositif_per_temp 
#WHERE per_date_debut >='2019-10-27 03:00:00'
#AND per_date_fin <='2019-10-27 04:00:00'; --4
@

<<report_df, echo=FALSE, eval=FALSE, include=FALSE>>=

r_df=new("report_df")
r_df<-choice_c(r_df,
    1,
    horodatedebut="2022-01-01",
    horodatefin="2022-12-31",
    silent=TRUE)
Sys.setenv(TZ='GMT')
r_df<-connect(r_df)

# normalement on doit pouvoir sortir ça directement dans le chunk calcul_debit_passe
# mais ici j'ai fait des modifications manuelles en sql/traitementç2022
#png(filename=file.path(imgwd,CY,"temps_fonctionnement_passe.png"),7,7,units="in",res=300)
#g <- graph_DF(r_df@data)
#print(g)
#dev.off()

png(filename=paste0(imgwdy,"report_df_annee.png"),width=10,height=6, units="in",res=300)
t_periodefonctdispositif_per=r_df@data
tpp<-split_per_day(t_periodefonctdispositif_per,horodatedebut="per_date_debut",horodatefin="per_date_fin")
g<-ggplot(tpp)+
    geom_rect(aes(xmin=xmin,xmax=xmax,ymin=Hdeb,ymax=Hfin,col=factor(per_tar_code),fill=factor(per_tar_code)),alpha=0.5)+
    scale_fill_manual("type",values=c("1"=bleu_EV,"2"=turquoise_EV,"3"=jaune_EV,"4"=orange_EV,"5"="#999999"),
        labels = gettext("Normal oper.","Operational stop","Stop","Dysfunct.","Unknown",domain="R-stacomiR"))+
    scale_colour_manual("type",values=c("1"=bleu_EVf,"2"=turquoise_EVf,"3"=jaune_EVf,"4"=orange_EVf,"5"="black"),
        labels = gettext("Normal oper.","Operational stop","Stop","Dysfunct.","Unknown",domain="R-stacomiR"))+		
    ylab("Heure")+
    theme(
        plot.background = element_rect(fill ="white"),
        panel.background = element_rect(fill="white"),
        legend.background=element_rect(fill="white"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        text=element_text(colour="black"),								
        line = element_line(colour = "grey50"),
        legend.key=element_rect(fill="white",colour=bleu_EV),
        axis.text=element_text(colour="black"))
print(g)
dev.off()
Sys.setenv(TZ="Europe/London")
r_df_hist<-choice_c(r_df,
    1,
    horodatedebut="2003-01-01",
    horodatefin=str_c(CY,"-12-31"),
    silent=TRUE)
r_df_hist<-connect(r_df_hist)

# Je fais rentrer tout le graphe sur une demie colonne ça rend bien.

png(filename=paste0(imgwdy,"report_df_2003_2022.png"),width=6,height=12, units="in",res=300)
plot(r_df_hist,plot.type=1,
    color_type_oper = 	c(
        "Fonc normal" = bleu_EV,
        "Arr ponctuel" = turquoise_EV, 
        "Arr maint" = jaune_EV,
        "Dysfonc" = orange_EV, 						
        "Non connu" = "#999999"
    ),
    color_etat=c("TRUE"=bleu_EV, 
        "FALSE"=orange_EV))
dev.off()

png(filename=paste0(imgwdy,"report_df_fct_2003_2022.png"),width=6,height=12, units="in",res=300)
plot(r_df_hist,plot.type=2,
    color_type_oper = 	c(
        "Fonc normal" = bleu_EV,
        "Arr ponctuel" = turquoise_EV, 
        "Arr maint" = jaune_EV,
        "Dysfonc" = orange_EV, 						
        "Non connu" = "#999999"
    ),
    color_etat=c("TRUE"=bleu_EV, 
        "FALSE"=orange_EV))
dev.off()
r_df_2<-choice_c(r_df,
    1,
    horodatedebut="2011-01-01",
    horodatefin="2022-12-31",
    silent=TRUE)
r_df_2<-connect(r_df_2)


# attention très très long
#png(filename=paste0(imgwdy,"report_df_2011_2022.png"),width=8,height=12, units="in",res=300)
#plot(r_df_2,plot.type=1,
#		color_type_oper = 	c(
#				"Fonc normal" = bleu_EV,
#				"Arr ponctuel" = turquoise_EV, 
#				"Arr maint" = jaune_EV,
#				"Dysfonc" = orange_EV, 						
#				"Non connu" = "#999999"
#		),
#		color_etat=c("TRUE"=bleu_EV, 
#				"FALSE"=orange_EV))
#dev.off()
#
#png(filename=paste0(imgwdy,"report_df_fct_2011_2022.png"),width=8,height=12, units="in",res=300)
#plot(r_df_2,plot.type=2,
#		color_type_oper = 	c(
#				"Fonc normal" = bleu_EV,
#				"Arr ponctuel" = turquoise_EV, 
#				"Arr maint" = jaune_EV,
#				"Dysfonc" = orange_EV, 						
#				"Non connu" = "#999999"
#		),
#		color_etat=c("TRUE"=bleu_EV, 
#				"FALSE"=orange_EV))
#dev.off()

@

<<report_dc, echo=FALSE, eval=FALSE, include=FALSE>>=
r_dc=new("report_dc")
r_dc<-choice_c(r_dc,
    5,
    horodatedebut="1998-01-01",
    horodatefin=str_c(CY,"-12-31"),
    silent=TRUE)
r_dc1 <- connect(r_dc)
plot(r_dc1,plot.type="1",
    color_type_oper = 	c(
        "Fonc normal" = bleu_EV,
        "Arr ponctuel" = turquoise_EV, 
        "Arr maint" = jaune_EV,
        "Dysfonc" = orange_EV, 						
        "Non connu" = "#999999"
    ),
    color_etat=c("TRUE"=turquoise_EV, 
        "FALSE"=jaune_EV)) 
g_report_dc_1=get('g_report_dc_1',envir_stacomi)
png(filename=paste0(imgwdy,"report_dc_1998_2022.png"),width=6,height=12, units="in",res=300)
g_report_dc_1 +
    theme(strip.background = element_rect(colour = "grey", fill = "grey20")		
    ) + 
    labs(title="Fonctionnement du dispositif de comptage",
        x ="mois", y = "Durée")
dev.off()
#r_dc<-choice_c(r_dc,
#		5,
#		horodatedebut="2010-01-01",
#		horodatefin=str_c(CY,"-12-31"),
#		silent=TRUE)
#r_dc2 <- connect(r_dc)
#png(filename=paste0(imgwdy,"report_dc_2010_",CY,".png"),width=8,height=12, units="in",res=300)
#plot(r_dc2,plot.type="1",
#		main="",
#		color_type_oper = 	c(
#				"Fonc normal" = bleu_EV,
#				"Arr ponctuel" = turquoise_EV, 
#				"Arr maint" = jaune_EV,
#				"Dysfonc" = orange_EV, 						
#				"Non connu" = "#999999"
#		),
#		color_etat=c("TRUE"=turquoise_EV, 
#				"FALSE"=jaune_EV))
#dev.off()
r_dc<-choice_c(r_dc,
    5,
    horodatedebut=str_c(CY,"-01-01"),
    horodatefin=str_c(CY,"-12-31"),
    silent=TRUE)
r_dc3 <- connect(r_dc)
png(filename=paste0(imgwdy,"report_dc_",CY,".png"),width=10,height=6, units="in",res=300)
plot(r_dc3,plot.type="3",
    color_type_oper = 	c(
        "Fonc normal" = bleu_EV,
        "Arr ponctuel" = turquoise_EV, 
        "Arr maint" = jaune_EV,
        "Dysfonc" = orange_EV, 						
        "Non connu" = "#999999"
    ),
    color_etat=c("TRUE"=turquoise_EV, 
        "FALSE"=jaune_EV))
dev.off()
vvv$ref_dc <- list()
vvv$ref_dc$date_debut <- strftime(
    (r_dc3@data%>%
      filter(per_etat_fonctionnement==1)%>%
      pull(per_date_debut))
        [1],"%d/%m/%Y")
vvv$ref_dc$date_fin <- strftime(
    (r_dc3@data%>%
      filter(per_etat_fonctionnement==1)%>%
      arrange(desc(per_date_debut))%>%
      pull(per_date_fin))
        [1],"%d/%m/%Y")
save(vvv,file=str_c(datawdy,"vvv.Rdata"))
@

<<load_from_hubeau, echo=FALSE, eval=FALSE, include=FALSE>>=


# list_apis()
#list_endpoints("temperature")
#list_params(api = "temperature", endpoint ="station")
#View(get_temperature_stations(code_departement = "56"))
#get_temperature_stations(code_departement = "35")
##  04216000     VILAINE à RIEUX 
#
#get_temperature_chronique(
#    code_station = "04216000",
#    date_debut_mesure = "2022-01-01",
#    date_fin_mesure="2023-12-31",
#    fields = paste("code_station,date_mesure_temp,heure_mesure_temp,resultat,symbole_unite")
#)
# 04214295     ARON à GRAND-FOUGERAY
aron <- get_temperature_chronique(
    code_station = "04214295",
    date_debut_mesure = str_c(CY,"-01-01"),
    date_fin_mesure=str_c(CY,"-12-31"),
    fields = paste("code_station,date_mesure_temp,heure_mesure_temp,resultat,symbole_unite")
)
# données journalières,  %T>% sort le graphique mais passe à la ligne suivante
hubeau_aronj <- aron %>% mutate(
        date = lubridate::ymd(date_mesure_temp),
        horodate_mesure_temp=lubridate::ymd_hms(str_c(date_mesure_temp," ",heure_mesure_temp)),
        #jour=strftime(as.POSIXlt(date), "%j")
        ) %T>%
    with(.,plot(horodate_mesure_temp,resultat)) %>% 
    group_by(date, date_mesure_temp, code_station) %>% 
    summarise(resultat=mean(resultat, na.rm=TRUE),.groups="drop") %>%
    rename(temp_aron = resultat) 

# this one uses an exposition pipe    
hubeau_aronj %$%    plot(date,temp_aron)    


# save data
save(hubeau_aronj, file =str_c(datawdy, "hubeau_aronj.Rdata"))
@


<<ecrit_env_passe, echo=FALSE, eval=FALSE, include=FALSE>>=

# traitement des données --------------------------------------------

load(file=file.path(datawd,CY,"fonct_pass.Rdata"))
load(file =str_c(datawdy, "hubeau_aronj.Rdata"))
dat <- ll$dat
dat$date <- as.Date(dat$time)
plot(dat$temperature_corde1_cran)
points(dat$temperature_corde2_cran, col="red")
# calcul des moyennes journalières
datj <- dat %>% group_by(date) %>% summarise(
    niveau_vil = mean(niveau_vilaine_barrage, na.rm=TRUE),
    temp_cran1 = mean(temperature_corde1_cran, na.rm=TRUE),
    temp_cran2 = mean(temperature_corde2_cran, na.rm=TRUE),
    temp_air_arz = mean(temperature_externe_barrage, na.rm=TRUE),
    debit_cran = mean(debit_pont_de_cran, na.rm=TRUE),
    debit_arzal = mean(debit_vilaine_estime, na.rm=TRUE), .groups="drop"
)
datj <- left_join(datj, 
    hubeau_aronj %>% select(date, temp_aron), by="date")
# graph des temperatures
datj %>% select(date, temp_cran1,temp_cran2, temp_air_arz, temp_aron) %>%
    tidyr::pivot_longer(cols=!date, names_to="station",values_to="temperature") %T>%
    {print(ggplot(data=., aes(x=date,y=temperature,col=station)) + geom_point())}
# tous
datjl <- datj %>%
    tidyr::pivot_longer(cols=!date, names_to="station",values_to="env_valeur_quantitatif") 
# vérifions les données déjà inscrites cette année en base dans la table tj_stationmesure_stm
req<- new("RequeteDB")
req <- connect(req)
res <- dbGetQuery(req@connection,glue("SELECT * FROM iav.tj_stationmesure_stm
            join iav.tj_conditionenvironnementale_env on env_stm_identifiant = stm_identifiant
            WHERE extract(year from env_date_debut)={CY}"))

if (nrow(res)!=0){
  cat('Attention il y a déjà des données dans la base pour les stations', paste(unique(res$stm_libelle), collapse=", "))
}

#ecriture en base --------------------------------------------------------
station <- dbGetQuery(req@connection,glue("SELECT * FROM iav.tj_stationmesure_stm"))
tj_ce <- datjl %>% arrange(date) %>% filter(date>=as.Date(str_c(CY,"-01-01"))) %>%
    left_join(station,by=c("station"="stm_libelle")) %>%
    mutate(env_org_code="IAV",
        env_date_fin=date+1,
        env_methode_obtention = "MESURE"
    ) %>%
    filter(!is.na(env_valeur_quantitatif)) %>%
    select( env_date_debut=date,
        env_date_fin,
        env_methode_obtention,
        env_valeur_quantitatif,
        env_stm_identifiant = stm_identifiant,
        env_org_code
    )


con <- dbConnect(RPostgres::Postgres(), dbname="bd_contmig_nat_iav", host=host, port=5432, user=user, password=password)



# ATTENTION ECRITURE EN BASE !!!!

DBI::dbWriteTable(req@connection, "tj_conditionenvironnementale_env_temp", tj_ce, overwrite=TRUE)
DBI::dbExecute(req@connection, "INSERT INTO iav.tj_conditionenvironnementale_env (
        env_date_debut
        ,env_date_fin
        ,env_methode_obtention
        ,env_valeur_quantitatif
        ,env_stm_identifiant
        ,env_org_code)
        SELECT env_date_debut
        ,env_date_fin
        ,env_methode_obtention
        ,env_valeur_quantitatif
        ,env_stm_identifiant
        ,env_org_code
        FROM tj_conditionenvironnementale_env_temp") #2309


@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Conditions environnementales}

L'année \Sexpr{CY} a été marquée par des débits de crue en début et en
fin d'année et des débits globalement plus importants que les débits de
référence de la banque hydro (Figure \ref{fig_debit}).
\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/fig_debit.png} 
\caption{Débits de la Vilaine en \Sexpr{CY}. En bleu les débits mesurés au Pont
de Cran, à l'aide d'une sonde à ultrasons, en orange les débits instantanés au
barrage d'Arzal (volets et vannes). Chaque point représente la valeur moyenne calculée toute les
dix minutes, noter l'absence de débit par les volets et les vannes en période
estivale. Les débits de référence mensuels moyens de la banque hydro au pont de
Cran sont donnés en marron.}
\label{fig_debit}
\end{figure}

<<plot_debit_vilaine, echo=FALSE, eval=FALSE, include=FALSE>>=
load(file.path(datawd,CY,"res.Rdata"))
d1 <- res$result[[match("debit_vilaine_estime",res$name)]]
d2 <- res$result[[match("debit_pont_de_cran",res$name)]]
colnames(d2)[2]<- "debit_pont_de_cran"
colnames(d1)[2]<- "debit_vilaine_estime"
d1[,"debit_vilaine_estime"][d1[,"debit_vilaine_estime"]>1500] <- NA
d3 <- full_join(d1,d2)
d3$HoroDate <- as.POSIXct(strptime(d3$HoroDate, format='%Y-%m-%d %H:%M:%S'))

# ci dessous pour geom step ajouter deux foix la valeur décembre
Q <-data.frame(Q=c(187.0 ,	177.0 ,	128.0 ,	68.50 ,	47.50 ,	33.40 ,	15.80 ,	11.10 ,	10.40 ,	18.40 ,	52.40 ,	119.0, 119.0),
    mois<-c(seq(1,12,1),12))		
Q$j=as.POSIXct(strftime(str_c(CY,"-",Q$mois,"-",01),format='%Y-%m-%d'))
Q$j[length(Q$j)] <- as.POSIXct(strftime(str_c(CY,"-","12","-",31),format='%Y-%m-%d'))

png(file=str_c(imgwdy,"fig_debit.png"),width=7,height=7,units="in",res=300)
ggplot(d3)+
    geom_point(aes(x=HoroDate, y=debit_pont_de_cran),lwd=1.2,col=bleu_EV) +
    geom_point(aes(x=HoroDate, y=debit_vilaine_estime),size=0.5,col="orange") +
    geom_step(aes(x=j,y=Q), data=Q, col=marron,lwd=2, alpha=0.8)+
    ylab(expression(debit~m^3*s^-1))+
    xlab(str_c("date  (",CY,")"))+
    scale_color_manual("Débit",
        values=c(bleu_EV,orange_EV),
        breaks=c("débit Pont de Cran","Débit Barrage"), 
        guide="none")+
    theme_bw()
dev.off()
@
\clearpage
\subsection{Mulet}
\makebox[-10pt]{ % decale vers le base par rapport 
  \begin{tikzpicture}[overlay]
  \node[inner sep=0pt] (muc) at (150pt,30pt)
      {
      \includegraphics[width=.15\textwidth]{mulet.png}
      };
   \node[inner sep=0pt] (status) at (100pt,35pt)
      {
      \includegraphics[width=0.5cm]{LC.jpg}
      };     
  \end{tikzpicture}
}
\fbox{\begin{minipage}[t]{0.48\textwidth}
\par\small
\titlefont\textcolor{bleu_EV}{
Le mulet porc \textit{Chelon ramada} est considéré en France comme
l’espèce de Mugilidés la plus ubiquiste tant en cours d’eau qu’en zône côtière
\citep{farrugio_biologie_1974,gautier_mulets_2005}. 
A partir du printemps, le mulet porc peut effectuer des migrations sur des longues distances 
entre les eaux marine et douce pour trouver des habitats favorables à sa
croissance. La reproduction a lieu fin
d'automne-début hiver, sur la zone littorale à proximité des estuaires. Il migre
donc à l'automne en avalaison sur les fleuves pour rejoindre le littoral.
Il fait l'objet d'une exploitation par la pêche professionnelle en Vilaine, 
et constitue après l'anguille la première espèce en effectif dans les comptages
aux passes à poissons du barrage d'Arzal.
En France les effectifs de mulet sont aujourd’hui en régression 
\citep{bartulovic_reproductive_2011}, l'espèce est néanmoins classée en
préoccupation mineure sur la liste rouge de l'IUCN.
Sur la Vilaine au barrage d’Arzal, parmi les mulets, seul \textit{Chelon
ramada} remonte l’estuaire pour migrer en eau douce \citep{briand_suivi_2018b}.
 En effet, le passage des poissons entre le milieu estuarien et le milieu de
 rivière provoque une variation brutale de salinité entre l'eau estuarienne et l'eau douce, 
 que seule \textit{Chelon ramada} pourrait supporter à l’aller et au retour de migration
 \citep{briand_suivi_2018b}.
 La présence de la seule espèce euryhaline et le confinement à la zone estuarienne 
 des autres espèces communes en Bretagne \textit{Chelon labrosus} et \textit{Chelon aurata}
 est cependant à confirmer \citep{gautier_mulets_2005,trancart_analyse_2011}.}
 \end{minipage}}
\smallskip



Compte tenu des effectifs très importants de mulets franchissant le barrage
d'Arzal chaque année, les comptages n'ont pas été effectués sur l'ensemble de la
période de suivi historique de la passe. Ils ont été effectués en 1996 et
1997, en 2013 et de 2015 à 2022. Lors des pics de migration, le comptage des
mulets est effectué par lots (dizaine) et la taille des poissons est analysée
sur un échantillon.
La structure en
taille des mulets présente à la fois des variations saisonnières et
interannuelles (Figure \ref{figure_taille_mulets}). Les mulets les plus grands
se présentent en tout début de saison, puis la taille des mulets diminue pour
atteindre son minimum lors de l'été \citep{lemonnier_dynamique_2019}.
Cette année comme en 2019 les mulets de petite taille, qui constituent une
majeure partie des effectifs, ne sont pas présents, sans que le fonctionnement
de la passe puisse expliquer cette absence.

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/graphe_taille_mulets.pdf} 
\caption{Tendance saisonnière d'évolution des
tailles de mulets depuis 2013. A. Graphiques de densités (distributions) des
tailles par mois, en jaune mois estivaux, en violet mois printaniers, en rose
automne. B. Graphique en violon et box-plot des tailles annuelles. C. Modèle gam
ajusté sur les valeurs de taille (au centre modèle et intervalle de confiance
 à 95 \%) les points correspondent à prédiction + résidus.}
\label{figure_taille_mulets}
\end{figure}



\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/bilan_annuel_mup} 
\caption{Bilan annuel des migrations de mulets au barrage d'Arzal.}
\label{bilan_annuel_mup}
\end{figure}

Les effectifs de mulets de 2022
N=\Sexpr{format(vvv[["MUP"]][["NCY"]], digits=1, nsmall =0, big.mark=" ",scientific=FALSE)}
sont comparables à ceux de la période 2014-2022 avec des variations entre des effectifs de 200~000 à 600~000 mulets. 
Les variations des effectifs de petits mulets sont en 
grande partie liée à l'abondance des mulets de classe de taille de 200 à 300 mm
\citep{lemonnier_dynamique_2019} (Tableau \ref{table_bilanannuel_mulets_0108}, Figure
\ref{bilan_annuel_mup}).

A partir de septembre, on note une augmentation des effectifs de mulets dans la
passe (Figure \ref{rmi_journalier_mup}) et les bancs de mulets commencent à
descendre la Vilaine pour retourner en mer participer à leur reproduction
annuelle. Les mulets peuvent alors faire des remontées dans la passe et la
structure en taille des mulets réaugmente en général en fin de saison. Les
raisons de la remontée à l'automne des mulets dans la passe ne sont pas connues,
mais le passage brutal de l'eau douce à l'eau salée en estuaire nécessite
probablement un temps d'adaptation pour effectuer la régulation osmotique.
Ainsi, les chiffres de migration totale représentent probablement un biais dans
l'interprétation de la taille de la population de mulets en Vilaine et un calcul
du nombre de mulets migrant jusqu'au mois de septembre (exclu) est donné au
Tableau \ref{table_bilanannuel_mulets_0108}.


%\input{\Sexpr{vvv[["MUP"]][["path"]]}} % table_bilanannuel_mulets
\input{\Sexpr{vvv[["MUP"]][["path0108"]]}} % table_bilanannuel_mulets

La migration des mulets
est essentiellement diurne et matinale (Figure \ref{horaires_mulet}) et elle
dépend également du niveau mer avec une grande part des passages pour des niveaux mer
>0m (Figure \ref{horaires_maree_mulet}).

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/horaires_mulet} 
\caption{Horaires de migration des mulets en \Sexpr{CY}.}
\label{horaires_mulet}
\end{figure}

\input{\Sexpr{vvv[["MUP"]][["pathmensuel"]]}}

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/bmm_horaires_maree} 
\caption{Passage des mulets en fonction de l'heure et du niveau mer en
\Sexpr{CY}.}
\label{horaires_maree_mulet}
\end{figure}


\clearpage
\onecolumn

\begin{landscape}
\begin{figure}[htpb]
\centering
\includegraphics[width=0.9\linewidth,keepaspectratio]{2022/rmi_journalier_mup.png} 
\caption{Bilan annuel des migrations de mulets \textit{Chelon ramada} au barrage
d'Arzal.}
\label{rmi_journalier_mup}
\end{figure}
\end{landscape}

<<bilan_car_lots_mup, echo=FALSE, eval=FALSE, include=FALSE >>=

options(warn=-1)


r_sample_char<-new("report_sample_char")
# the following will load data for size, 
# parameters 1786 (total size) C001 (size at video control)
# dc 5 passe à bassins
r_sample_char<-choice_c(r_sample_char,
    dc=c(5),
    taxa=c(2183),
    stage=c("IND"),
    par=c(1786,"C001"),
    horodatedebut="2013-01-01",
    horodatefin=str_c(CY,"-12-31"),
    silent=TRUE)
# lancement 
r_sample_char<-connect(r_sample_char, silent=TRUE)
r_sample_char<-calcule(r_sample_char, silent=TRUE)

#x11()

#hcl_palettes(plot = TRUE)

# graphique des données quantitatives
png(filename=paste0(imgwd,"taille.png"),width=600,height=400)
g <- ggplot(r_sample_char@data)
g <- g+
    geom_jitter(aes(x=ope_date_debut,y=car_valeur_quantitatif, col=annee),
        width = 0.5, 
        height = 0.5, 
        alpha=0.5) +
    scale_colour_discrete_qualitative(
        palette = "Pastel1", nmax = 7, order = 2:7)+
    xlab("Date")+
    ylab("Taille des mulets (mm)")+
    theme_dark()
print(g)
dev.off()
options(warn=0)
save(r_sample_char, file=str_c(datawd,CY,"r_sample_char.Rdata"))
@

<<modele_taille_mup, echo=FALSE, eval=FALSE, include=FALSE >>=
load_package("mgcv")
load_package("itsadug")
load_package("visreg")
load_package("ggpubr")
###################################
# modélisation de la taille moyenne des mulets 
###################################
load(file=str_c(datawd,CY,"r_sample_char.Rdata"))
dat <- r_sample_char@data
#dat[dat$car_valeur_quantitatif> 700,]
#str(dat)
dat$date <- dat$ope_date_debut # je cree une variable date qui sera plus tard transformée
# en facteur dans les modèles
# ci dessous une fonction pour extraire les dates
fndate<-function(data, origine="01012013"){
  #browser()
  if (!"date"%in%colnames(data)) stop ("date should be in colnames(data)")
  if (!class(data$date)[1]=="POSIXct") stop("date should be POSIXct")
  if (!class(origine)=="character") stop("date should be a character")  
  origine=dmy(origine)
  data$month <- lubridate::month(data$date)
  data$year<-lubridate::year(data$date)
  # lubridate::yday(lubridate::dmy(01082008))
  data$yday=lubridate::yday(data$date)			
  data$time=as.numeric(as.Date(data$date)-origine)
  data$hour=hour(data$date)
  data$date <- as.factor(as.Date(data$date))
  data$year <-as.factor(data$year)
  return(data)
}
dat <- fndate(dat)
dat <- rename(dat, taille_mm=car_valeur_quantitatif)

###########################################"
# Quel est l'écart type moyen des tailles de mulets journalières
############################################
(allsd <- dat %>%
      group_by(date) %>%                                           # groupe par date
      summarize(sd=sd(taille_mm, na.rm=TRUE)) %>%                  # ecart type
      ungroup() %>%                                                # degroupe
      pull(sd) %>%                                                 # calcule ecart type
      mean(na.rm=TRUE))                                            # moyenne de l'écart type

###################################
# graphique en densité montrant la distribution de taille par mois
# les couleurs sont choisies pour mettre en contraste les valeurs
# des mois estivaux et printemps+ automne
###################################
dat$mois <- as.factor(dat$month)
g0 <- ggplot(dat)+
    geom_density(aes(x=taille_mm, fill=mois),alpha=0.5)+
    facet_grid(.~year)+
    scale_fill_discrete_sequential(
        palette = "Plasma",order=c(10:7,1:3, 4:6))+ 
    xlab("Taille (mm)")+
    ggpubr::theme_pubr(legend="bottom")+
    theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.line.x = element_blank())+
    rotate()#+
#guides(fill = guide_legend(nrow = 1))
print(g0)


# Violin plots with box plots inside
# :::::::::::::::::::::::::::::::::::::::::::::::::::
# Change fill color by groups: dose
# add boxplot with white fill color

colours <- qualitative_hcl(CY-2013, "Pastel_1")
g1 <- ggviolin(dat, x = "year", y = "taille_mm", fill = "year",
        palette = colours,
        add = "boxplot", add.params = list(fill = "white"))+
    theme_transparent()+
    theme(legend.position = "none")





# dat[1:100,c("time","yday","year")]


#
#g0 <- gam(taille_mm ~ s(yday),  data=dat)
#
#
#g0m <- bam(taille_mm ~ s(yday,bs="cc")+ s(date,bs="re"),  data=dat)
#
#g1m <- bam(taille_mm ~ s(yday,bs="cc",by=year)+ s(date,bs="re"),  data=dat)
#
##x11()
##plot(g0) ; plot(g0, resid=TRUE,shade=TRUE)
##residuals=FALSE
##summary(g0)
#
#compareML(g0m,g1m)#g1m
## gam.check(g1m)
## visreg(g1m,xvar="date",  ylab= "taille mm")
## visreg(g1m,xvar="yday", by="year", ylab= "taille mm")
#compareML(gamm2,gamm3)#gamm2 est meilleur
#
#g3m <- bam(taille_mm ~ s(yday,bs="cc",by=year)+s(date,bs="re"),  data=dat)
#summary(g3m)
#visreg(g3m, xvar="date",  ylab= "taille mm")
#visreg(g3m, xvar="yday", by="year", ylab= "taille mm")
g4m <- gam(taille_mm ~ s(yday,bs="cc", by=year,k=8)+s(time,k=3),  data=dat)


plot(acf(resid(g4m)))
plot(pacf(resid(g4m))) # pas bon, il faudrait utiliser un gamm, je vais pas donner de stats
g2mm <- gam(taille_mm ~ s(time,k=3),  data=dat)
g4mm <- gam(taille_mm ~ s(yday,bs="cc", by=year,k=8)+s(time,k=3),  data=dat)
g3mm <- gam(taille_mm ~ s(yday,bs="cc", by=year,k=8),  data=dat)
g5mm <- gam(taille_mm ~ s(yday,bs="cc", k=8)+s(time,k=3),  data=dat)

# model 3 is best g4mm
anova(g3mm,g3mm,g4mm,g5mm, test="Chisq")


#anova(g2mm,g4mm,test="Chisq")
#visreg(g4m, xvar="time",  ylab= "taille mm")
#visreg(g4m, xvar="yday",by="year",  ylab= "taille mm")


#stargazer::stargazer(g3mm,g4mm,g5mm)#summary(g4m)
#
#summary(g2mm)
#g2mm
#summary(g3mm)
#g3mm
#summary(g4mm)
#g4mm
#summary(g5mm)
#g5mm



############################################
# Prédictions du modèle sur le jeu de données d'origine
############################################

dat$pred <-predict(g4m, type="response",se.fit=TRUE)$fit
# 95 % des données de prédiction sont entre fit *se.fit et fit-2*se.fit
dat$lwr <-dat$pred-2*predict(g4m, type="response",se.fit=TRUE)$se.fit
dat$upr <-dat$pred+2*predict(g4m, type="response",se.fit=TRUE)$se.fit
dat$lwrPoint <-dat$pred - 2*allsd
dat$uprPoint <-dat$pred + 2*allsd
dat$upr <-dat$pred+2*predict(g4m, type="response",se.fit=TRUE)$se.fit




###############################"
# graphiques du modèle, des données avec prédiction
################################
# g1 plot brut des tailles de mulets
g2 <- ggplot(dat)+    
    scale_colour_discrete_qualitative(
        palette = "Pastel1", nmax = CY-2013)+
    scale_fill_discrete_qualitative(
        palette = "Dark2", nmax = CY-2013)+
    xlab("Date")+
    ylab("Taille des mulets (mm)")+
    theme_dark()


g3 <- g2 +  
    
    geom_ribbon(aes(x=ope_date_debut,ymin=lwrPoint,ymax=uprPoint,colour=annee),
        fill="grey40",alpha=0.2)+
    
    geom_jitter(aes(x=ope_date_debut,y=taille_mm, col=annee),
        size=1,
        width = 0.5, 
        height = 0.5, 
        alpha=0.5) +
    
    geom_ribbon(aes(x=ope_date_debut,ymin=lwr,ymax=upr, fill=annee),
        color="white",alpha=0.9)+   
    
    geom_point(aes(x=ope_date_debut,y=pred, fill=annee), 
        shape=23,size=0.8, fill="white")

###############################################"
# combinaison de plusieurs graphiques
# http://www.sthda.com/english/articles/24-ggpubr-publication-ready-plots/81-ggplot2-easy-way-to-mix-multiple-graphs-on-the-same-page/
################################################

p1 <- ggarrange(g0, g1, labels=c("A", "B"),
    ncol = 2, nrow = 1)
p2 <- ggarrange(g3, labels="C")
p3 <- ggarrange(p1, p2, nrow=2, ncol=1)

pdf(file.path(imgwd,CY,"graphe_taille_mulets.pdf"),width=8, height=8)
print(p3)
dev.off()

#################################################################
# prédicton des  donnéees avec loi normale +- 2 *sd autour de la moyenne
#################################################################
# creation du tableau de prédiciton
pred <-
    data.frame("date"=
            as.POSIXct(seq(from=as.POSIXct(dmy("01012013")), to = as.POSIXct(dmy("30072022")), by="1 day")))
pred <- fndate(pred)
pred <- pred[pred$yday>59&pred$yday<319,]
pred <- pred[pred$year!="2014",]

# prediction
predo <- predict.gam(object=g4m,type="response", se.fit = TRUE, newdata=pred)
pred <-  cbind(pred, 
    "fit"=predo$fit,
    "se.fit"=predo$se.fit)
pred$date <- as.Date(pred$date)
plot(pred$date, pred$fit)


the_seq <- seq(0,600,by=5)
ma<-matrix(NA,nrow=nrow(pred),ncol=length(the_seq))
# prediction normale tous les jours avec la moyenne et l'écart type
# commun à tout le jeu de données
for (i in 1:nrow(pred)){
  ma[i,]<- dnorm(the_seq, mean=pred$fit[i],sd=allsd)
}
load_package("plot3D")
plot3D::image2D(ma)
ma <-ma/rowSums(ma)
mad <- as.data.frame(ma)
save(ma,file=paste0(datawd,"ma.Rdata"))
the_seq <- seq(0,600,by=5)
colnames(mad) <-str_c("t",the_seq)
pred2 <- cbind(pred,mad)
save(pred2,file=paste0(datawd,"pred2.Rdata"))
save(vvv , file=file.path(datawd,CY,"vvv.Rdata"))
@





<<bilan_annuels_mup, echo=FALSE, eval=FALSE,include=FALSE >>=



# launching stacomi without selecting the scheme or interface
bilA <- new("report_annual")
bilA <- choice_c(bilA,
    dc=c(5),
    taxa=c("Liza ramada"),
    stage=c("IND"),
    start_year="1996",
    end_year=CY,
    silent=FALSE)

bilA <- connect(bilA)	
bilA@data <- bilA@data[!bilA@data$annee%in%c(2007,2008),]
options(encoding = "UTF-8")
xtbilA<-stacomiR::xtable(bilA,
    caption="Migration des mulets dans la passe à bassins du barrage d'Arzal 
        (passe à fentes verticales).",
    label="table_bilanannuel_mulets",
    dc_name=c("P. bassins")		
)

# below not run but one can create a file as following
save(bilA, file= str_c("bilAmup",CY,".Rdata"))
#load(file= str_c("bilAmup",CY,".Rdata"))
path=file.path(tabwdy,
    paste(paste(bilA@dc@dc_selected,collapse="_"),"_",
        paste(bilA@taxa@taxa_selected,collapse="_"),"_",
        paste(bilA@stage@stage_selected,collapse="_"),"_",
        bilA@start_year@year_selected,"to",
        bilA@end_year@year_selected,".tex",sep=""),fsep ="")
# the following uses the "addtorow" argument which creates nice column headings,
# format.args creates a thousand separator
# again this will need to be saved in a file using the file argument

print(xtbilA,
    file=path,
    add.to.row= list(pos=list(0),
        command=				
            "\\multicolumn{2}{c}{\\textit{Chelon ramada}}  \\\\ 
            \\multicolumn{2}{c}{Indéterminé} \\\\"),
    include.rownames = TRUE,
    include.colnames = FALSE,
    format.args = list(big.mark = " ", decimal.mark = ","),
    booktabs=TRUE
)
options(encoding = "native.enc")
#===================================================

png(filename=str_c(imgwdy,"bilan_annuel_mup.png"))
ggplot(bilA@data)+ geom_col(aes(x=annee,y=effectif), fill=bleu_EV)+
    ylab("Effectif (mulet)") + 
    xlab("Année") +
    theme_bw()
dev.off()

#===================================================
# total 
total <- bilA@data
#vvv[["MUP"]]<- list()# normalement vient du rapport de l'années précédente
vvv[["MUP"]][["path"]] <- gsub("C:/workspace/","../../../",path)

somme_mup<-round(tapply(bilA@data$effectif,bilA@data$annee,sum))
indiceCY <- match(as.character(CY),names(somme_mup))
vvv[["MUP"]][["N"]] <- as.data.frame(total[,c(1,2)])
vvv[["MUP"]][["NCY"]] <- somme_mup[indiceCY]

vvv[["MUP"]][["rank"]]<-nrow(somme_mup)+1-rank(somme_mup)[indiceCY]
vvv[["MUP"]][["maxrank"]]<-nrow(somme_mup)



#####################################
# Bilan migration (jusqu'au 01/09 seulement)
#####################################
req<- new("RequeteDB")
req <- connect(req)
res <- dbGetQuery(req@connection,glue("select sum(lot_effectif) as effectif_mont,
            annee, 
            ope_dic_identifiant,
            lot_tax_code, 
            lot_std_code  
            FROM (
            SELECT *, extract(year  from ope_date_debut) as annee
            FROM iav.t_operation_ope  
            JOIN iav.t_lot_lot on lot_ope_identifiant=ope_identifiant 
            WHERE ope_dic_identifiant in('5') 
            AND extract(year from ope_date_debut)>=1996 
            AND extract(year from ope_date_fin)<=",CY,"  
            AND extract(month FROM ope_date_debut) < 9
            AND lot_tax_code in ('2183') 
            AND lot_std_code in ('IND') 
            AND lot_lot_identifiant is null
            ) as tmp
            GROUP BY annee, ope_dic_identifiant, lot_tax_code, lot_std_code"  
    ))
load(file= str_c("bilAmup",CY,".Rdata"))
res <- res[,c(1,2)]
restt<-bilA@data

res2 <-inner_join(restt,res)[!res$annee%in%c(2007,2008),c("annee","effectif","effectif_mont")]
colnames(res2) <- c("Année","N annuel","N 01-08")
bilA@data <- res
options(encoding = "UTF-8")
xtmup <- xtable(res2,
    digits = 0,
    caption="Migration des mulets dans la passe à bassins du barrage d'Arzal 
        (passe à fentes verticale), pour l'année complète et pour la période de montaison 
        (jusqu'au 31 août.)",
    label="table_bilanannuel_mulets_0108")		

path=file.path(tabwdy,
    paste(paste(bilA@dc@dc_selected,collapse="_"),"_",
        paste(bilA@taxa@taxa_selected,collapse="_"),"_",
        paste(bilA@stage@stage_selected,collapse="_"),"_",
        bilA@start_year@year_selected,"to",
        bilA@end_year@year_selected,"0108.tex",sep=""),fsep ="")
# the following uses the "addtorow" argument which creates nice column headings,
# format.args creates a thousand separator
# again this will need to be saved in a file using the file argument
print(xtmup,
    file=path,
    add.to.row= list(pos=list(0),
        command=				
            "&\\multicolumn{2}{c}{\\textit{Chelon ramada}}  \\\\
            &\\multicolumn{2}{c}{Indéterminé} \\\\
            "),
    include.rownames = FALSE,
    include.colnames = TRUE,
    format.args = list(big.mark = " ", decimal.mark = ","),
    booktabs=TRUE
)
options(encoding = "native.enc")
vvv[["MUP"]][["path0108"]] <- gsub("C:/workspace/","../../../",path)
total <- bilA@data
somme_mup <- round(tapply(bilA@data$effectif,bilA@data$annee,sum))
indiceCY <- match(as.character(CY),names(somme_mup))
vvv[["MUP"]][["N0108"]] <- as.data.frame(total[,c(1,2)])
vvv[["MUP"]][["NCY0108"]] <- somme_mup[indiceCY]
save(vvv,file=str_c(datawdy,"vvv.Rdata"))
@

<<report_mig_mult_mulet, echo=FALSE, eval=FALSE,include=FALSE >>=
load_package("wesanderson")
color_ope<-sample(c(mycolorramp1(10),mycolorramp2(10)),20)
bMM_Arzal=new("report_mig_mult")
bMM_Arzal=choice_c(bMM_Arzal,
    dc=c(5),
    taxa=c("Liza ramada"),
    stage=c("IND"),
    datedebut=str_c(CY,"-01-01"),
    datefin=str_c(CY,"-12-31"))
bMM_Arzal <- charge(bMM_Arzal)
bMM_Arzal <- connect(bMM_Arzal)
bMM_Arzal <- calcule(bMM_Arzal)
color_ope<-sample(c(mycolorramp1(10),mycolorramp2(10)),20)
# par("din") # pour voir la taille de la fenetre graphique
png(file=str_c(imgwdy,"bmm_mulet.png"),7,7,units="in",res=300)
plot(bMM_Arzal,plot.type="standard",
    color=color,
    color_ope=color_ope,
    main=str_c("Effectif de mulets porcs (Chelon ramada) en ",CY),
    cex.main=1.1,		
    type="h",
    silent=TRUE)
dev.off()


#####################
# Horaires de passage
######################
mig <- bMM_Arzal@data
mig <- mig %>% mutate(time=strftime(ope_date_debut, format="%H:%M:%S"),
    date=as.Date(ope_date_debut))
# ATTENTION RECOMPILER fun_date_extraction dans stacomiR il y avait une erreur

fun_date_extraction=function(data, # tableau de donnees e importer
    nom_coldt, # nom de la colonne
    annee=TRUE,
    mois=TRUE,
    quinzaine=FALSE,
    semaine=TRUE,
    semaine_std=FALSE,
    jour_an=FALSE,
    jour_mois=TRUE,
    heure=FALSE                           
){
  if (annee) data$annee <- as.factor(strftime(as.POSIXlt(data[,nom_coldt]), format="%Y"))                        
  if (mois) data$mois <- as.factor(strftime(as.POSIXlt(data[,nom_coldt]), format="%m"))
  # %b Abbreviated month name in the current locale. (Also matches full name on input.)
  if (quinzaine) {
    data$quinzaine=ceiling(as.numeric(strftime(as.POSIXlt(data[,nom_coldt]),
                format="%W"))/2)
    data$quinzaine <- as.character(data$quinzaine)
    data$quinzaine[as.numeric(data$quinzaine)<10] <- paste("0", data$quinzaine[as.numeric(data$quinzaine)<10],sep="")
    data$quinzaine <- as.factor(data$quinzaine)
  }
  if (semaine) data$semaine <- as.factor(strftime(as.POSIXlt(data[,nom_coldt]), format="%W"))
  #%W : Week of the year as decimal number (00e53) using Monday as the first day of week (and typically with the first Monday of the year as day 1 of week 1). The UK convention
  if (jour_an) data$jour_365 <- strftime(as.POSIXlt(data[,nom_coldt]), format="%j")                          
  if (jour_mois) data$jour_mois <- as.factor(strftime(as.POSIXlt(data[,nom_coldt]), format="%d"))  
  # %d :  Day of the month as decimal number (01e31).
  if (heure) data$heure <- as.factor(strftime(as.POSIXlt(data[,nom_coldt]), format="%H"))  
  #%H     Hours as decimal number (00e23).    
  if (semaine_std) data$semaine_std=lubridate::isoweek(as.POSIXlt(data[,nom_coldt]))
  return(data)
}    


mig <-	fun_date_extraction(
    data=mig,
    nom_coldt="ope_date_debut", annee = FALSE, mois = TRUE,
    quinzaine = FALSE, semaine = FALSE, semaine_std = FALSE,
    jour_an = FALSE, jour_mois = TRUE, heure = TRUE)
hhh <- mig %>% group_by(heure) %>% summarize(N=sum(value))
png(file=str_c(imgwdy,"horaires_mulet.png"),7,7,units="in",res=300)
g <- ggplot(hhh, aes(x = heure)) + 
    geom_histogram(aes(y=N), width = 0.6, colour = NA,stat="identity") +
    coord_polar(start=3*pi/4) +
    theme_minimal() +	
    ylab("Nombre") 
print(g)
dev.off()
hhh <- mig %>% group_by(heure, mois) %>% summarize(N=sum(value))
load(file=file.path(datawd,CY,"fonct_pass.Rdata"))	# ll
mig$time <- strptime(strftime(mig$ope_date_debut, format="%Y-%m-%d %H:%M"),"%Y-%m-%d %H:%M")
mig$timec <- as.POSIXct(strptime(strftime(mig$ope_date_debut, format="%H:%M:%S"),format="%H:%M:%S"))
mige<-inner_join(mig, ll$dat,by="time")

hhh<- mige%>%group_by(heure) %>% summarize(N=sum(value))

png(file=str_c(imgwdy,"bmm_horaires_maree.png"),7,7,units="in",res=300)
ggplot(mige)+
    geom_point( aes(x=timec,y=niveau_mer_barrage,col=value))+	
    scale_colour_gradientn(colors=wesanderson::wes_palette("Zissou1", n = 5, type="continuous"), 
        breaks=c(0,10,100,1000,10000),trans = "log") +
    scale_fill_gradientn(colors=wesanderson::wes_palette("Zissou1", n = 5, type="continuous"), 
        breaks=c(0,10,100,1000,10000),trans = "log") +
    scale_x_datetime(date_labels = "%H")+
    xlab("Heure")+
    theme_bw()
dev.off()

@






<<report_mig_internnual_mulet, echo=FALSE, eval=FALSE,include=FALSE >>=
###########################################
# Bilan interannuel de stacomi
#########################################

bmi <- new("report_mig_interannual")
bmi <- choice_c(bmi,
    dc=c(5),
    taxa=c("Liza ramada"),
    stage=c("IND"),
    start_year="1996",
    end_year=CY,
    silent=TRUE)


bmi <- charge(bmi,silent=TRUE)
bmi <- connect(bmi,silent=FALSE)
bmi <- calcule(bmi)
#save(bmi,file=str_c(datawd,'bmimup2022.Rdata'))
#load(file=str_c(datawd,'bmi2022.Rdata'))
#str(bmi)

plot(bmi)
g=get("g1",envir_stacomi)
nb_annee<-length(unique(bmi@data$bjo_annee))
mycolorramp1<-colorRampPalette(c("#011A2D","#4F7EA2"))
mycolorramp2<-colorRampPalette(c("#462800","#B68B52"))
color_ope<-c(rev(mycolorramp1(10)),mycolorramp2(nb_annee-11),"#85A3BA")
#============================================
png(filename=str_c(imgwdy,"rmi_journalier_mup.png"),10,7,units="in",res=300)
g <- g+scale_x_datetime(name="date",
        date_breaks="months",
        date_minor_breaks="weeks", 
        date_labels="%d-%m"#,
    #limits=as.POSIXct(strptime(c("2000-03-15","2000-07-01"),format=,"%Y-%m-%d"))
    )+
    ylab("Effectifs capturés ou montés dans la passe")+
    theme_bw()+ 
    theme(legend.key = element_blank())
print(g)
dev.off()

plot(bmi,plot.type="barchart", timesplit="mois")
g<-get("g1", envir=envir_stacomi)
cols <- c("max" = "#012746","min" = "#6C3E00",">=moy" = "#327AB5", "<moy" = "#D29035","hist_mean"="black","hist_range"="grey","?"="#D26435")
fills <- c("max" = "#043C6B","min" = "#6C3E00",">=moy" = "#558AB5", "<moy" = "#D2A25F","hist_mean"="black","hist_range"="grey","?"="#D26435")
g <- g + scale_colour_manual(name=CY,values=cols,limits=c("min","max","<moy",">=moy","hist_mean","hist_range","?"))
g <- g + scale_fill_manual(name=CY,values=fills,limits=c("min","max","<moy",">=moy","hist_mean","hist_range","?"))
g <- g + ggtitle("")
#============================================
png(filename=str_c(imgwdy,"barchart_bmi_mup.png"))
print(g)
dev.off()
#============================================

plot(bmi,plot.type="density",timesplit="semaine")
colrp <- colorRampPalette(colors=rev(c("#6D9A58","#0E2C00")))
colrp1 <- colorRampPalette(colors=c("#6D9A58","#C6B130"))
load_package("viridis")
g <- get("g",envir=envir_stacomi)	
g +
    ggplot2::scale_fill_manual(values=c(colrp(12),colrp1(12)))


#============================================
png(filename=str_c(imgwdy,"plot_seasonal_mup.png"),width=14,height=10,unit="cm",res=300)
plot(bmi, plot.type="seasonal", timesplit="semaine") 
dev.off()

# ====== Bilan mensuel ===============

mmm <- summary(bmi,silent=TRUE)$'5' 
mmm <- mmm[,-1]
options(encoding = "UTF-8")
colnames(mmm) <- c("Mois", "Min*", "Moyenne*", "Max*", "N (2022)")
xtmmm <- xtable(mmm,caption="Migrations mensuelles des mulets dans la passe à bassins du barrage d'Arzal, $N$ nombre, * correspondent à
        la période 1996-2022. min* minimum mensuel, max* maximum mensuel, moyenne* moyenne des effectifs mensuels.",
    label="table_lpm_mois",
    digits=c(0,0,0,0,0,0),
    display = c("s","s","f","f", "f", "f"))
path_y <- file.path(tabwdy,
    paste(5,"_",
        paste(bmi@taxa@taxa_selected, collapse="_"),"_",
        paste(bmi@stage@stage_selected,collapse="_"),"_"
        ,"mensuel.tex",sep=""),fsep ="")
print(xtmmm,
    file=path_y,
    format.args = list(big.mark = " ", decimal.mark = ","),
    table.placement=c("htbp")
#include.rownames = FALSE => OK set as global options
)
options(encoding = "native.enc")

vvv[["MUP"]][["pathmensuel"]] <- path_y
save(vvv, file=str_c(datawdy,"vvv.Rdata"))
@

\clearpage
\twocolumn
\subsection{Lamproie marine}
%\vspace{5pt} % utiliser innertopmargin
\makebox[-10pt]{
  \begin{tikzpicture}[overlay]
  \node[inner sep=0pt] (lpm) at (150pt,30pt)
      {
      \includegraphics[width=.12\textwidth]{lpm.png}
      };
  \node[inner sep=0pt] (status) at (100pt,28pt)
      {
      \includegraphics[width=0.5cm]{EN.jpg}
      };        
  \end{tikzpicture}
}
\fbox{
\begin{minipage}[t]{0.48\textwidth}
\par\small
\titlefont\textcolor{bleu_EV}{
Les lamproies \textit{Petromyzon marinus} sont des vertébrés primitifs de
la classe des Agnathes (sans mâchoire, avec une bouche circulaire), 
et ne sont donc pas à proprement parler des poissons. La lamproie marine est une espèce amphihaline. 
Elle ne se reproduit qu'une seule fois en eau douce en mai-juin, avec un homing
\footnote{\textcolor{bleu_EVf}{retour à la rivière de naissance}} faible.
Les larves ammocètes vivent enfouies dans les sédiments et les litières pendant 5 à 7 ans.
Après métamorphose, les lamproies dévalent en mer où elles vivent 1 à 2 ans en tant que parasite externe
sur des poissons ou des mammifères.
Au niveau national, la tendance des abondances est à la baisse, surtout sur les
sites qui étaient les plus fréquentés (Gironde, Loire), alors qu'en Bretagne, la chute est moins marquée. 
La contribution de la Vilaine à l'échelle de la France, très faible aux débuts des années 2000, 
est aujourd'hui non négligeable. Sur la Vilaine, les migrations de 2016 à 2019 
ont été très mauvaises, mais les saisons 2020 et 2022 marque un retour à la
normale.
L'espèce est classée en danger en France sur la liste rouge UICN.}
\end{minipage}}
\smallskip



Les migrations de lamproies marine sur la Vilaine qui étaient en fort déclin
après 2015 ont réaugmenté à un niveau proche du niveau historique
(N=\Sexpr{num(vvv$LPM$N[match(2020,vvv$LPM$N$annee),1])}) en 2020.
Cette année, les effectifs ont été de nouveau relativement faibles avec 
\Sexpr{num(vvv$LPM$NCY)} lamproies marines (Figure \ref{barplot_report_annual_lpm}, Tableau \ref{table_bilanannuel_lpm}) ce qui place l'année au \Sexpr{num(vvv$LPM$rank)} ème rang sur les
\Sexpr{num(nrow(vvv$LPM$N))} années de suivi à Arzal.
Les raisons des variations d'effectif restent mal comprises.


		
\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/barplot_report_annual_lpm.png} 
\caption{Histogramme des effectifs annuels de lamproies marines comptabilisés
au barrage d'Arzal.}
\label{barplot_report_annual_lpm}
\end{figure}


La comparaison des tendances mensuelles avec les migrations
interannuelles montre qu'elles sont inférieures à la moyenne observée sur la
période 1996-2020 sauf en mars (Figure \ref{barchart_bmi_lpm}, Tableau
\ref{table_lpm_mois}).

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/barchart_bmi_lpm.png} 
\caption{Comparaison de la migration de lamproies marines de \Sexpr{CY} avec la
série interannuelle de données 1996-\Sexpr{CY-1}.}
\label{barchart_bmi_lpm}
\end{figure}



\input{\Sexpr{vvv[["LPM"]][["path_y"]]}} % table bilan annuel lamproies
\input{\Sexpr{vvv[["LPM"]][["path"]]}} % table bilan lamproies pour l'année


La migration des lamproies marines intervient entre mars et juin (Figure
\ref{rmi_density_lpm}). En \Sexpr{CY}, la migration s'est faite essentiellement
de mars à mai. Les premières migrations sont clairement plus précoces, et les
migrations de mars correspondent au maximum connu jusqu'alors 
(Figures \ref{barchart_bmi_lpm}, \ref{plot_seasonal_lpm}).
Ces résultats sont en accord avec l'examen des tendances de migration des
lamproies marines en France par \citet{legrandContrastingTrendsSpecies2020} qui
montre globalement une arrivée plus précoce dans les 30 dernières années. 
Les dates de première arrivée correspondant à l'arrivée de 5 \% des
effectifs annuels, arrivée médiane (quand 50 \% des lamproies ont migré) et
arrivées tardives (95 \%) ne varient pas de manière indépendante pour la
lamproie. 

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/rmi_density_lpm.png} 
\caption{Saisonnalité de la migration des lamproies marines, les pourcentages
par quinzaine sont cumulés.}
\label{rmi_density_lpm}
\end{figure}


\begin{figure}[htpb]
\centering
\includegraphics[width=0.49\textwidth]{2022/plot_seasonal_lpm.png} 
\caption{Saisonnalité de la migration des lamproies marines, effectifs
hebdomadaires. Les
barres représentent le 5 ème et le 95 ème percentile de la migration. Le
point la médiane. L'importance des effectifs est représentée par la couleur.}
\label{plot_seasonal_lpm}
\end{figure}

La comparaison des structures en taille vidéo de cette année laisse apparaître
un accroissement de la taille, alors que la taille des aloses a fortement
diminué. C'est à partir de 2019 qu'une nouvelle méthode de mesure a été
appliquée : la taille a été mesurée relativement à 9 sections de la vitre de
comptage pour prendre en compte les déformations de la lentille de la caméra. 
Or l'aumentation est observée depuis 2015, elle ne peut donc pas être attribuée
au changement de méthode de mesure. L'augmentation de la taille des lamproies
est donc un phénomène notable, comme pour les variations d'effectifs, les raisons de cette augmentation de taille ne
sont pas connues (Figure \ref{size_lpm}).

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/size_lpm.png} 
\caption{Comparaison des structure en taille des lamproies marines. Les tailles
de 2019 et 2022 ont été calculées en prenant en compte la déformation des distances dans les
différentes zones de la vitre.}
\label{size_lpm}
\end{figure}

<<report_mig_mult_lpm, echo=FALSE, eval=FALSE,include=FALSE >>=
# Lamproies --------------------------------------- 
color_ope <- sample(c(mycolorramp1(10),mycolorramp2(10)),20)
bMM_Arzal <- new("report_mig_mult")
bMM_Arzal <- choice_c(bMM_Arzal,
    dc=c(5),
    taxa=c("Petromyzon marinus"),
    stage=c("11"),
    datedebut=str_c(CY,"-01-01"),
    datefin=str_c(CY,"-12-31"))
bMM_Arzal <- charge(bMM_Arzal)
bMM_Arzal <- connect(bMM_Arzal)
bMM_Arzal <- calcule(bMM_Arzal)
png(file=str_c(imgwdy,"bmm_lpm.png"),7,7,units="in",res=300)
plot(bMM_Arzal,plot.type="standard",
    color=color,
    color_ope=color_ope,
    main=str_c("Effectif de lamproies marines en ", CY),
    cex.main=1.1,		
    type="h",
    silent=TRUE)
dev.off()
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<report_interannual_lpm, echo=FALSE, eval=FALSE, include=FALSE >>=
rmi <- new("report_mig_interannual")
rmi <- choice_c(rmi,
    dc=c(5),
    taxa=c("Petromyzon marinus"),
    stage=c("11"),
    start_year="1996",
    end_year=CY,
    silent=TRUE)
rmi <- charge(rmi)
rmi <- connect(rmi,check=TRUE,silent=FALSE)	
rmi <- calcule(rmi)

# utilisation de la méthode plot pour générer un graphique des densités
# puis modification des couleurs du titre et de y
plot(rmi,plot.type="density",silent=TRUE)
g <- get("g",envir=envir_stacomi)
nb_annee <- length(unique(rmi@data$bjo_annee))
mycolorramp1 <- colorRampPalette(c("#011A2D","#4F7EA2"))
mycolorramp2 <- colorRampPalette(c("#462800","#B68B52"))
color_ope <- c(rev(mycolorramp1(10)),mycolorramp2(nb_annee-11),"#85A3BA")
#============================================
png(filename=str_c(imgwdy,"rmi_density_lpm.png"))
g+ggplot2::scale_fill_manual(values=color_ope)+
    ggplot2::ggtitle("")+
    theme(
        panel.border = element_blank(),
        panel.background = element_blank(),
        panel.grid.minor = element_line(colour = "white"),
        panel.grid.major = element_line(colour = "white"),
        panel.grid.major.x = element_line(colour = "white"))
dev.off()
#============================================
plot(rmi,plot.type="barchart",timesplit="mois",silent=TRUE)
g<-get("g1",envir=envir_stacomi)
cols <- c("max" = "#012746","min" = "#6C3E00",">=moy" = "#327AB5", "<moy" = "#D29035","hist_mean"="black","hist_range"="grey","?"="#D26435")
fills <- c("max" = "#043C6B","min" = "#6C3E00",">=moy" = "#558AB5", "<moy" = "#D2A25F","hist_mean"="black","hist_range"="grey","?"="#D26435")
g <- g+scale_colour_manual(name=CY,values=cols,limits=c("min","max","<moy",">=moy","hist_mean","hist_range","?"))
g <- g+scale_fill_manual(name=CY,values=fills,limits=c("min","max","<moy",">=moy","hist_mean","hist_range","?"))
g <- g+ggtitle("")
#============================================
png(filename=str_c(imgwdy,"barchart_bmi_lpm.png"))
print(g)
dev.off()
#============================================
png(filename=str_c(imgwdy,"plot_seasonal_lpm.png"),width=14,height=10,unit="cm",res=300)
plot(rmi, plot.type="seasonal", timesplit="semaine") 
dev.off()

# ====== Bilan mensuel ===============

mmm <- summary(rmi,silent=TRUE)$'5' 
mmm <- mmm[,-1]
colnames(mmm) <- c("Mois", "Min*", "Moyenne*", "Max*", "N (2022)")
xtmmm <- xtable(mmm,caption="Migrations mensuelles des lamproies marines dans la passe à bassins du barrage d'Arzal, $N$ nombre, * correspondent à
        la période 1996-2022. min* minimum mensuel, max* maximum mensuel, moyenne* moyenne des effectifs mensuels.",
    label="table_lpm_mois",
    digits=c(0,0,0,0,0,0),
    display = c("s","s","f","f", "f", "f"))
path_y <- file.path(tabwdy,
    paste(5,"_",
        paste(rmi@taxa@taxa_selected,collapse="_"),"_",
        paste(rmi@stage@stage_selected,collapse="_"),"_"
        ,"mensuel.tex",sep=""),fsep ="")
print(xtmmm,
    file=path_y,
    format.args = list(big.mark = " ", decimal.mark = ","),
    table.placement=c("htbp")#,
#include.rownames = FALSE => OK set as global options
)
#vvv[["LPM"]]<- list()# normalement vient du rapport de l'années précédente
vvv[["LPM"]][["path_y"]]<-gsub("C:/workspace/","../../../",path_y)

save(vvv,file=str_c(datawdy,"vvv.Rdata"))
@

<<report_annual_lpm, echo=FALSE, eval=FALSE,include=FALSE >>=
###############################
# Bilan annuel des migrations
###############################
ra<-new("report_annual")
ra<-choice_c(ra,
    dc=c(5),
    taxa=c("Petromyzon marinus"),
    stage=c("11"),
    start_year=1996,
    end_year=CY,
    silent=TRUE)
ra <- connect(ra,silent=FALSE)
png(filename=str_c(imgwdy,"barplot_report_annual_lpm.png"))
barplot(ra)
dev.off()
xtra<-stacomiR::xtable(ra,
    caption="Migration des lamproies marines dans la passe à bassins du barrage
        d'Arzal (passe à fentes verticales).",
    label="table_bilanannuel_lpm",
    dc_name=c("P. bassins")		
)
# below not run but one can create a file as following

path=file.path(tabwdy,
    paste(paste(ra@dc@dc_selected,collapse="_"),"_",
        paste(ra@taxa@taxa_selected,collapse="_"),"_",
        paste(ra@stage@stage_selected,collapse="_"),"_",
        ra@start_year@year_selected,"to",
        ra@end_year@year_selected,".tex",sep=""),fsep ="")
# the following uses the "addtorow" argument which creates nice column headings,
# format.args creates a thousand separator
# again this will need to be saved in a file using the file argument
print(xtra,
    file=path,
    add.to.row= list(pos=list(0),
        command=				
            "\\multicolumn{2}{c}{\\textit{Petromyzon marinus}}  \\\\
            \\multicolumn{2}{c}{Géniteur} \\\\"),
    include.rownames = TRUE,
    include.colnames = FALSE,
    format.args = list(big.mark = " ", decimal.mark = ","),
    booktabs=TRUE
)

# some manual editing needed....
#===================================================
png(filename=str_c(imgwdy,"bilan_annuel_lpm.png"))
barplot(ra,args.legend=list(x="topleft",bty = "n"),
    col=c(marron),
    ylab="Effectif (lamproie marine)")
dev.off()
#===================================================
# total 
total <- ra@data

vvv[["LPM"]][["path"]] <- gsub("C:/workspace/","../../../",path)

somme<-round(tapply(ra@data$effectif,ra@data$annee,sum))
indiceCY <- match(as.character(CY),names(somme))
vvv[["LPM"]][["N"]] <- as.data.frame(total[,c(1,2)])
vvv[["LPM"]][["NCY"]] <- somme[indiceCY]

vvv[["LPM"]][["rank"]]<-nrow(somme)+1-rank(somme)[indiceCY]
vvv[["LPM"]][["maxrank"]]<-nrow(somme)
save(vvv,file=str_c(datawdy,"vvv.Rdata"))
@

<<report_sample_char_lpm, echo=FALSE, eval=FALSE,include=FALSE >>=
library("stacomiR")

# launching stacomi without selecting the scheme or interface
stacomi()

r_sample_char<-new("report_sample_char")
r_sample_char<-choice_c(r_sample_char,
    dc=c("5"),
    taxa=c("Petromyzon marinus"),
    stage=c("11"),
    par=c("C001"),
    horodatedebut="1998-01-01",
    horodatefin=str_c(CY,"-12-31"),
    silent=FALSE)
r_sample_char<-connect(r_sample_char)
r_sample_char<-calcule(r_sample_char,silent=TRUE)
# A "violin" plot
plot(r_sample_char,plot.type="1",silent=TRUE)

g<-get("g",envir=envir_stacomi)
png(filename=str_c(imgwdy,"size_lpm.png"))
g+ggplot2::xlab("taille video (mm)")+
    ggplot2::ylab("annee")+
    theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
dev.off()
@

\clearpage
\subsection{Aloses}

%\vspace{5pt} % utiliser innertopmargin
\makebox[-2.5pt]{
  \begin{tikzpicture}[overlay]
  \node[inner sep=0pt] (alose) at (150pt,30pt)
      {
      \begin{turn}{0}
      \includegraphics[width=.12\textwidth]{aloses.png}
      \end{turn}
      };
  \node[inner sep=0pt] (status) at (100pt,28pt)
      {
      \includegraphics[width=0.5cm]{CR.jpg}
      };    
  \end{tikzpicture}
}
\fbox{\begin{minipage}[t]{0.48\textwidth}
\par\small
\titlefont\textcolor{bleu_EV}{Poisson migrateur amphihalin de la famille des
Clupéidés (sardine …).
La grande alose \textit{Alosa alosa} ne se reproduit généralement qu'une seule
fois, en eau douce en mai-juin, souvent sur sa rivière d'origine ou dans un cours d'eau 
proche géographiquement. Les alosons restent à proximité des frayères quelques mois 
avant de dévaler en automne vers l'estuaire, puis rapidement en mer pour une phase 
de croissance d'environ 5 ans. Les femelles sont plus massives que les mâles et restent 
généralement une année de plus en mer.
Au niveau national, la tendance est à une chute très marquée, 
surtout sur les sites qui étaient les plus fréquentés (Gironde, Loire).
En Bretagne, la situation est plutôt à l'amélioration, et la Vilaine fait partie
des principaux sites avec le Blavet et l'Aulne. Après la période 2012-2016 où 
la pêche professionnelle estuarienne a fortement impacté la migration, on a
constaté un renforcement des effectifs sans toutefois jamais atteindre les
valeurs historiques des années 2000. Les effectifs sont de nouveau en baisse sur
la Vilaine. L'espèce est classée en danger critique d’extinction en France sur
la liste rouge UICN.
}
\end{minipage}}
\smallskip

\Sexpr{vvv$ALA$NCY} aloses ont été comptées en
\Sexpr{CY} (Figure
\ref{tx_exploit} \ref{rmi_journalier_ala} et Tableau
\ref{table_bilanannuel_ala}).
Cette migration place l'année \Sexpr{CY} au rang \Sexpr{vvv$ALA$rank}
par rapport à l'ensemble des années de migration. En
vidéo comptage, il n'est pas possible de distinguer les deux espèces, grande
alose \textit{Alosa alosa} et alose feinte \textit{Alosa fallax}.


%\begin{figure}[htpb]
%\centering
%\includegraphics[width=0.45\textwidth]{2022/bilan_annuel_ala.png} 
%\caption{Histogramme des effectifs annuels d'aloses comptabilisés
%au barrage d'Arzal.}
%\label{bilan_annuel_ala}
%\end{figure}

\input{\Sexpr{vvv[["ALA"]][["path"]]}} 


\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/rmi_journalier_ala.png} 
\caption{Comparaison de la migration d'aloses de \Sexpr{CY} avec la série
interannuelle de données 1996-\Sexpr{CY-1}.}
\label{rmi_journalier_ala}
\end{figure}


Quel que soit le mois, les migrations sont inférieures à la
moyenne interannuelle (Figures
\ref{barchart_bmi_ala} \ref{rmi_journalier_ala}, Tableau \ref{table_ala_mois}).

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/barchart_bmi_ala.png} 
\caption{Comparaison de la migration d'aloses de \Sexpr{CY} avec la série
interannuelle de données 1996-\Sexpr{CY-1}.}
\label{barchart_bmi_ala}
\end{figure}

La comparaison des structures en taille vidéo de cette année laisse apparaître
une forte diminution de la taille moyenne après une tendance sur plusieurs
années à l'augmentation des effectifs.
A compter de 2019, la taille a été mesurée relativement à 9 sections de la vitre de comptage pour prendre en compte les
déformations de la lentille de la caméra. Ainsi les tailles avant 2019 et 2022
sont peut être légèrement plus petites (Figure \ref{size_alose}).
La diminution de la taille moyenne en 2020 semblait cohérente avec un retour des
premières aloses ayant fait l'objet de mesures de protection 5 ans auparavant en
2015, et la relative rareté des grandes aloses correspondant à la période de
surexploitation en 2012-2014. Cette année les tailles ont clairement ré-augmenté.
Le scénario pourrait être le suivant, pas assez de reproducteurs entre 2013 et
2014, quelques reproductions en 2015 arrivent en 2020 à l'âge 5 (petites
aloses.). Cette même cohorte se retrouve en 2022. Celà signifierait un succès
reproducteur très faible des alose ayant migré en 2016, c'est plutôt inquiétant
car les effectifs auraient du commencer à ré-augmenter.



\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/size_alose.png}
\caption{Taille des aloses mesurées à Arzal. Densité (graphique en violon),
moyenne et +- 2 fois l'écart type (en bleu foncé). La couleur des points dépend
du mois de passage.}
\label{size_alose}
\end{figure}


Contrairement à l'année 2019 le début de la migration n'est pas particulièrement
précoce (Figure \ref{plot_seasonal_ala}).




\begin{figure}[htpb]
\centering
\includegraphics[width=0.49\textwidth]{2022/plot_seasonal_ala.png} 
\caption{Saisonnalité de la migration des aloses, effectifs hebdomadaires. Les
barres représentent le 5 ème et le 95 ème percentile de la migration. Le point
la médiane. L'importance des effectifs est représentée par la couleur.}
\label{plot_seasonal_ala}
\end{figure}

Depuis 2018, on considère qu'il n'y a pas eu d'exploitation
estuarienne de l'alose (Figure \ref{tx_exploit}). La gestion de la population d'aloses
de Vilaine a fait l'objet d'un
débat technique dans le cadre du Comité de gestion des poissons migrateurs de
Bretagne.
A partir des éléments collectés sur le bassin, et des données obtenues sur les
bassins voisins, un objectif de gestion en biomasse a été défini. Le
stock potentiel d'aloses sur la Vilaine est estimé entre 50~000 aloses, pour
le niveau actuel d'aménagement du bassin - c'est à dire un fort étagement
par le barrage d'Arzal puis par les ouvrages de l'Oust et de la Vilaine- , et
100~000 aloses pour une rivière en conditions pristines, c'est à dire une
rivière pour laquelle l'accès aux zones de frayères serait restauré. Une limite
en biomasse, celle en-dessous de laquelle on estime qu'il pourrait y avoir un
risque accru de diminution du stock, est proposée à 15~000 aloses. En dessous de
cette limite, la mortalité devrait être réduite pour remonter le stock à son
niveau optimal. Une règle de gestion a été proposée pour la gestion des
pêcheries. L'importance de l'aménagement des axes fluviaux pour l'accès aux
zones de reproduction a également été mise en avant (Figure \ref{tx_exploit}).

\textcolor{orange}{La question de la prédation du silure, dont les effectifs
sont en claire augmentation avec des tailles allant en s'accroissant, devra se poser l'année
prochaine si les effectifs n'augmentent pas.}


\vfill
\begin{figure}[pbt]
\centering
\includegraphics[width=0.5\textwidth]{2022/tx_exploit.png} 
\caption{Migration et taux d'exploitation des aloses en estuaire de Vilaine,
illustration de l'effet des mesures prises à partir de 2015 pour limiter
l'exploitation de l'espèce en estuaire. Interdictions par zones et saisonnières
de 2015 à 2017, puis interdiction totale saisonnière de pêche à partir de 2018.}
\label{tx_exploit}
\end{figure}
\newpage % column break

\input{\Sexpr{vvv[["ALA"]][["path_y"]]}} % tableau avec effectifs mensuels 

\clearpage %
\begin{landscape}
\begin{figure}[htpb]
\centering
\includegraphics[width=0.9\linewidth]{2022/preco_diagram.png} 
\caption{Diagramme de précaution pour la gestion des aloses en Vilaine, 
les données indiquent la position du stock par rapport à la règle de gestion proposée 
par le groupe de travail du cogepomi sur les aloses. 
En abscisse, niveau de biomasse par rapport à la cible de gestion, 
en ordonnée, mortalité cumulée (taux instantané) de la pêcherie estuarienne. 
Les données de la pêcherie fluviale, indisponibles, ne sont pas intégrées au
calcul.}
\label{preco_diagram}
\end{figure}
\end{landscape}

<<report_mig_mult_ala, echo=FALSE, eval=FALSE,include=FALSE >>=



# Aloses --------------------------------------- 

color_ope<-sample(c(mycolorramp1(10),mycolorramp2(10)),20)
bMM_Arzal=new("report_mig_mult")
bMM_Arzal=choice_c(bMM_Arzal,
    dc=c(5),
    taxa=c("Alosa"),
    stage=c("11"),
    datedebut=str_c(CY,"-01-01"),
    datefin=str_c(CY,"-12-31"))
bMM_Arzal<-charge(bMM_Arzal)
bMM_Arzal<-connect(bMM_Arzal)
bMM_Arzal=calcule(bMM_Arzal)

# par("din") # pour voir la taille de la fenetre graphique
png(file=str_c(imgwdy,"bmm_alose.png"),7,7,units="in",res=300)
plot(bMM_Arzal,plot.type="standard",
    color=color,
    color_ope=color_ope,
    main=str_c("Effectif d'aloses en ",CY),
    cex.main=1.1,		
    type="h",
    silent=TRUE)
dev.off()
@

<<struct_taille_ala, echo=FALSE, eval=FALSE,include=FALSE >>=


load_package("boot")
load_package("stringr")
load_package("dplyr")
load_package("lubridate")


# taille moyenne en cm (fourche) 46
taille_fch=46.1
# taille totale (fishbase) 53.5
taille_tot=taille_fch*(1/0.86)
# Poids (fishbase) (g)
poids=0.00492*taille_tot^3.202 # 1693.8


b_carlot<-new("report_sample_char")
b_carlot<-choice_c(b_carlot,
    dc=c(5),
    taxa=c("Alosa"),
    stage=c("11"),
    par=c("C001"),
    horodatedebut=as.Date("2010-01-01"),
    horodatefin=as.Date(str_c(CY+1,"-01-01")),
    silent=FALSE)
# two warning produced, ignored if silent=TRUE


# two warning produced, ignored if silent=TRUE
b_carlot<-charge(b_carlot)
b_carlot<-connect(b_carlot)
b_carlot<-calcule(b_carlot,silent=TRUE)

png(filename=str_c(imgwdy,"size_alose.png"))
# A set of useful summary functions is provided from the Hmisc package:
stat_sum_df <- function(fun, geom="crossbar", ...) {
  stat_summary(fun.data = fun, colour = bleu_EV, geom = geom, width = 0.4, alpha=0.8, ...)
}

g <- ggplot(b_carlot@data,aes(x=annee,y=car_valeur_quantitatif))
#fn_coul <- colorRampPalette(colors=c(bleu_EV,"white",marron))
#col <- fn_coul(length(levels(bilan_carlot@data$mois)))
g <- g +	geom_violin(color=marron,
        fill=marron,
        alpha=0.8)+   # build the base violins	
    geom_point(aes(color=mois),
        size=1,
        position=position_jitter(w = 0.05, h = 0.5))+
    theme_bw()+
    stat_sum_df("mean_sdl", fun.args = list(mult = 2), 
        mapping = aes(x=annee,y=car_valeur_quantitatif,group = annee))+
    theme_bw()+	
    scale_color_manual(values=wesanderson::wes_palette("Zissou1", 6, type = "continuous"))+
    ylab("taille")
print(g)
dev.off()

@

<<donnees_capture, echo=FALSE, eval=FALSE,include=FALSE >>=


fundatpech <- function(year,poids_moyen=1680,nomfichier="capture_"){
  datpech<-read.table(str_c(datawd,nomfichier,year,".csv"),header=TRUE,sep=";")
  colnames(datpech)<-c("Pecheur","Poids","gisement","temps","date")
  datpech<-datpech[!is.na(datpech$gisement),]
  #str(datpech)
  datpech<-stacomirtools::killfactor(datpech)
  datpech<-as.data.frame(select(datpech,date,Pecheur,Poids)%>%group_by(date)%>%summarize(capture=sum(Poids)))
  datpech$date=parse_date_time(datpech$date,"%d/%m/%Y")
  datpech<-datpech[order(datpech$date),]	
  datpech$nb=datpech$capture/poids_moyen
  datpech$jour=as.POSIXct(ymd(str_c("2000","-",month(datpech$date),"-",day(datpech$date))))
  datpech<-stacomirtools::killfactor(datpech)
}
#datpech2017<-fundatpech("2017",1693)
# correction d'après le ficher des ventes, voir traitement_capture.R
datpech2017 <- fundatpech("2017",1693,nomfichier="capturecor_")
datpech2016<-fundatpech("2016",1680)


@



<<report_interannual_ala, echo=FALSE, eval=FALSE,include=FALSE >>=

###########################################
# Bilan interannuel de stacomi
#########################################

bmi<-new("report_mig_interannual")
bmi<-choice_c(bmi,
    dc=c(5),
    taxa=c("Alosa"),
    stage=c("11"),
    start_year="1996",
    end_year=CY,
    silent=TRUE)


bmi<-charge(bmi,silent=TRUE)
bmi<-connect(bmi,silent=FALSE)
bmi<-calcule(bmi)
save(bmi,file=str_c(datawd,'bmiala2022.Rdata'))
#load(file=str_c(datawd,'bmi2022.Rdata'))
str(bmi)
####################
# graphique de stacomi (2018 pas de captures)
##########################
plot(bmi)
g=get("g1",envir_stacomi)
nb_annee<-length(unique(bmi@data$bjo_annee))
mycolorramp1<-colorRampPalette(c("#011A2D","#4F7EA2"))
mycolorramp2<-colorRampPalette(c("#462800","#B68B52"))
color_ope<-c(rev(mycolorramp1(10)),mycolorramp2(nb_annee-11),"#85A3BA")
#============================================
png(filename=str_c(imgwdy,"rmi_journalier_ala.png"),10,7,units="in",res=300)
g <- g+scale_x_datetime(name="date",
        date_breaks="months",
        date_minor_breaks="weeks", 
        date_labels="%d-%m",
        limits=as.POSIXct(strptime(c("2000-03-15","2000-07-01"),format=,"%Y-%m-%d")))+
    ylab(iconv("Effectifs capturés ou montés dans la passe","UTF8"))+
    theme_bw()+ 
    theme(legend.key = element_blank())
print(g)
dev.off()

plot(bmi,plot.type="barchart",timesplit="mois")
g<-get("g1",envir=envir_stacomi)
cols <- c("max" = "#012746","min" = "#6C3E00",">=moy" = "#327AB5", "<moy" = "#D29035","hist_mean"="black","hist_range"="grey","?"="#D26435")
fills <- c("max" = "#043C6B","min" = "#6C3E00",">=moy" = "#558AB5", "<moy" = "#D2A25F","hist_mean"="black","hist_range"="grey","?"="#D26435")
g <- g+scale_colour_manual(name=CY,values=cols,limits=c("min","max","<moy",">=moy","hist_mean","hist_range","?"))
g <- g+scale_fill_manual(name=CY,values=fills,limits=c("min","max","<moy",">=moy","hist_mean","hist_range","?"))
g<-g+ggtitle("")
#============================================
png(filename=str_c(imgwdy,"barchart_bmi_ala.png"))
print(g)
dev.off()
#============================================

plot(bmi,plot.type="density",timesplit="semaine")
colrp<-colorRampPalette(colors=rev(c("#6D9A58","#0E2C00")))
colrp1<-colorRampPalette(colors=c("#6D9A58","#C6B130"))
load_package("viridis")
g<-get("g",envir=envir_stacomi)	
g+
    ggplot2::scale_fill_manual(values=c(colrp(12),colrp1(12)))


#============================================
png(filename=str_c(imgwdy,"plot_seasonal_ala.png"),width=14,height=10,unit="cm",res=300)
plot(bmi,plot.type="seasonal",timesplit="semaine") 
dev.off()

# ====== Bilan mensuel ===============

mmm <- summary(bmi,silent=TRUE)$'5' 
mmm <- mmm[,-1]
colnames(mmm) <- c("Mois", "Min*", "Moyenne*", "Max*", "N (2022)")
xtmmm<-xtable(mmm,caption="Migrations mensuelles des lamproies marines dans la passe à bassins du barrage d'Arzal, $N$ nombre, * correspondent à
        la période 1996-2022. min* minimum mensuel, max* maximum mensuel, moyenne* moyenne des effectifs mensuels.",
    label="table_lpm_mois",
    digits=c(0,0,0,0,0,0),
    display = c("s","s","f","f", "f", "f"))
path_y=file.path(tabwdy,
    paste(5,"_",
        paste(bmi@taxa@taxa_selected,collapse="_"),"_",
        paste(bmi@stage@stage_selected,collapse="_"),"_"
        ,"mensuel.tex",sep=""),fsep ="")
print(xtmmm,
    file=path_y,
    format.args = list(big.mark = " ", decimal.mark = ","),
    table.placement=c("htbp")#,
#include.rownames = FALSE => OK set as global options
)
@


<<report_annual_ala, echo=FALSE, eval=FALSE,include=FALSE >>=
###############################
# Bilan annuel des migrations
###############################
ra	<-new("report_annual")
ra<-choice_c(ra,
    dc=c(5),
    taxa=c("Alosa"),
    stage=c("11"),
    start_year=1996,
    end_year=2022,
    silent=TRUE)


ra <- connect(ra,silent=FALSE)
save(ra,file=str_c(datawdy,"ra_mup_",CY,".Rdata"))
png(filename=str_c(imgwdy,"bilan_annuel_ala.png"))
barplot(ra,args.legend=list(x="topleft",bty = "n"),
    col=c("#6BB1C1"),
    ylab="Effectif (aloses)")
dev.off()

xtra<-stacomiR::xtable(ra,
    caption="Migration des aloses (Alosa sp.) dans la passe à bassins du barrage
        d'Arzal (passe à fentes verticales).",
    label="table_bilanannuel_ala",
    dc_name=c("P. bassins")		
)
# below not run but one can create a file as following

path <- file.path(tabwdy,
    paste(paste(ra@dc@dc_selected,collapse="_"),"_",
        paste(ra@taxa@taxa_selected,collapse="_"),"_",
        paste(ra@stage@stage_selected,collapse="_"),"_",
        ra@start_year@year_selected,"to",
        ra@end_year@year_selected,".tex",sep=""),fsep ="")
# the following uses the "addtorow" argument which creates nice column headings,
# format.args creates a thousand separator
# again this will need to be saved in a file using the file argument
print(xtra,
    file=path,
    add.to.row= list(pos=list(0),
        command=				
            "\\multicolumn{2}{c}{\\textit{Alosa sp.}}  \\\\ 
            \\multicolumn{2}{c}{Géniteur} \\\\"),		
    include.rownames = TRUE,
    include.colnames = FALSE,
    format.args = list(big.mark = " ", decimal.mark = ","),
    booktabs=TRUE
)

vvv[["ALA"]][["path"]] <- gsub("C:/workspace/","../../../",path)

somme<-round(tapply(ra@data$effectif,ra@data$annee,sum))
indiceCY <- match(as.character(CY),names(somme))
vvv[["ALA"]][["N"]] <- as.data.frame(ra@data[,c(1,2)])
vvv[["ALA"]][["NCY"]] <- somme[indiceCY]

vvv[["ALA"]][["rank"]]<-nrow(somme)+1-rank(somme)[indiceCY]
vvv[["ALA"]][["maxrank"]]<-nrow(somme)
save(vvv,file=str_c(datawdy,"vvv.Rdata"))

@
<<graphique_migration_capture_2017, echo=FALSE, eval=FALSE,include=FALSE >>=
# ###############################################
# GARDE POUR DES RAISONS HISTORIQUES... NE PAS LANCER
# Adaptation du script stacomi pour afficher les effectifs capturés
# il faut que le label soit effectif total pour passer dans la fonction fundat
# une fois qu'elle a tourné on rajoute une colonne supplémentaire au dataset de l'année en cours
# dat0 et à celui correspondant aux captures par pêches
# puis on l'ajoute dans l'argument fill à la place d'une couleur constant et on met position= stack
##################################################################################################
#dat=bmi@data
#datpech <- datpech2017
## je recrée un data frame identique avec des valeurs au hazard pour ce qui ne sert pas
#datpech2<-data.frame(bjo_identifiant=0,
#		bjo_dis_identifiant=0,
#		bjo_tax_code=2055,
#		bjo_std_code=11,
#		bjo_annee=2017,
#		bjo_jour=as.POSIXlt(datpech$jour),
#		bjo_labelquantite="Effectif_total",
#		bjo_valeur=datpech$nb,
#		bjo_horodateexport=dat$bjo_horodateexport[1], # au hazard on s'en fout
#		bjo_org_code="IAV")
#the_choice=max(dat$bjo_annee)
#
## dataset for current year
#dat0=fun_report_mig_interannual(dat,annee=NULL,timesplit=NULL)
#dat0$type="Passe"
#datpech0=fun_report_mig_interannual(dat=datpech2,annee=NULL,timesplit=NULL)
#datpech0$type="Capture"
#tmp <- rbind(dat0[as.numeric(as.character(dat0$annee))==the_choice,],datpech0)
#tmp$annee=as.character(tmp$annee)
#dat=fun_report_mig_interannual(dat,annee=the_choice,timesplit=NULL)				
#dat=dat[dat$moyenne!=0,] # pour des raisons graphiques on ne garde pas les effectifs nuls generes par fundat
#newdat=dat[match(unique(as.character(dat$jour)),as.character(dat$jour)),]
#newdat=newdat[order(newdat$jour),] # pour avoir les range sur l'ensemble des valeurs dispo et pas seult l'annee en cours
#amplitude=paste(min(as.numeric(as.character(dat$annee))),"-",max(as.numeric(as.character(dat$annee))),sep="")        
#
## le layout pour l'affichage des graphiques
#vplayout <- function(x, y) { grid::viewport(layout.pos.row = x, layout.pos.col = y)   }
#grid::grid.newpage()
#grid::pushViewport(grid::viewport(layout = grid::grid.layout(length(the_choice),1,just="center")))   
#amplitudechoice<-paste(the_choice,'/',amplitude)
#
#g <- ggplot(newdat,aes(x=jour))
#g <- g+geom_ribbon(aes(ymin=mintab, ymax=maxtab,fill="amplitude"),color="grey20",alpha=0.5)
#g <- g+geom_bar(aes(y=valeur,fill=type),position="stack",stat="identity",alpha=0.8,data=tmp)
#g<- g+ scale_fill_manual(name=eval(amplitudechoice), values=c("#35789C","#FF7C67","#FFDA67"),
#		labels = c("amplitude historique","captures","passe"))
##g <- g+geom_point(aes(y=valeur,col=annee),data=tmp,pch=16,size=1)  
## moyenne interannuelle
#
#g <- g+	geom_line(aes(y=moyenne,col=I("#002743")),data=newdat)
#g <- g+ geom_point(aes(y=moyenne,col=I("#002743")),size=1.2,data=newdat)		           
#g <- g+ scale_colour_manual(name=eval(amplitudechoice),values=c("#002743"),
#				labels=c(stringr::str_c("Moyenne interannuelle\n",amplitude)))+
#		guides(fill = guide_legend(reverse=TRUE))
#g <- g+labs(title=paste(bmi@taxa@data$tax_nom_latin,",",bmi@stage@data$std_libelle,unique(as.character(tmp$annee)),"/",amplitude))
#g <- g+scale_x_datetime(name="date",date_breaks="months",date_minor_breaks="weeks", date_labels="%d-%m",
#		limits=as.POSIXct(strptime(c("2000-03-01","2000-06-01"),format=,"%Y-%m-%d")))
#g<-g+ylab(iconv("Effectifs capturés ou montés dans la passe","UTF8"))
#g<-g+theme_bw()+ theme(legend.key = element_blank())
#print(g, vp=vplayout(1,1)) 
@


<<graph_table_suppl, echo=FALSE, eval=FALSE, include=FALSE >>=

########################################
# Bilan
#######################################


# 1 => lancer le breport interannual
# 2 => lancer donnees capture pour récupérer les données concernant la pêche
# ci dessous si relancé sélectionner la bonne année
#tapply(datpech2016$nb,lubridate::month(datpech2016$date),function(X)round(sum(X)))
#tapply(datpech2017$nb,lubridate::month(datpech2016$date),function(X)round(sum(X)))
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# ATTENTION BIEN LIRE IL FAUT SELECTIONNER A LA MAIN LES ANNEES COMME CI DESSOUS
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
load(file=str_c(datawd,'bmiala2022.Rdata'))
bmi2016 <- summary(bmi,year_choice=2016,silent=FALSE) 
bmi2017 <- summary(bmi,year_choice=2017,silent=FALSE)
bmi2018 <- summary(bmi,year_choice=2018,silent=FALSE) 
bmi2019 <- summary(bmi,year_choice=2019,silent=FALSE) 
bmi2020 <- summary(bmi,year_choice=2020,silent=FALSE) 
bmi2021 <- summary(bmi,year_choice=2021,silent=FALSE)
bmi2022 <- summary(bmi,year_choice=2022,silent=FALSE)
datmens <- data.frame("2016"=c("capture (nb)"=round(sum(datpech2016$nb)),
        "capture (kg)"=round(sum(datpech2016$capture/1000)),
        "migration(03)"=0,
        "migration(04)"=bmi2016[["5"]][1,6],
        "migration(05)"=bmi2016[["5"]][2,6],
        "migration(06-07)"=bmi2016[["5"]][3,6]),
    "2017"=c("capture (nb)"=round(sum(datpech2017$nb)),
        "capture (kg)"=round(sum(datpech2017$capture/1000)),
        "migration(03)"=bmi2017[["5"]][1,6],
        "migration(04)"=bmi2017[["5"]][2,6],
        "migration(05)"=bmi2017[["5"]][3,6],             
        "migration(06-07)"=round(sum(bmi2018[["5"]][c(4,5),6]))),
    "2018"=c("capture (nb)"=0,
        "capture (kg)"=0,
        "migration(03)"=0,
        "migration(04)"=bmi2018[["5"]][1,6],
        "migration(05)"=bmi2018[["5"]][2,6],
        "migration(06-07)"=round(sum(bmi2018[["5"]][c(3,4),6]))),            
    "2019"=c("capture (nb)"=0,
        "capture (kg)"=0,
        "migration(03)"=bmi2019[["5"]][1,6],
        "migration(04)"=bmi2019[["5"]][2,6],
        "migration(05)"=bmi2019[["5"]][3,6],
        "migration(06-07)"=NA),
    "2020"=c("capture (nb)"=0,
        "capture (kg)"=0,
        "migration(03)"=bmi2020[["5"]][1,6],
        "migration(04)"=bmi2020[["5"]][2,6],
        "migration(05)"=bmi2020[["5"]][3,6],
        "migration(06-07)"=NA),
    "2021"=c("capture (nb)"=0,
        "capture (kg)"=0,
        "migration(03)"=bmi2021[["5"]][1,6],
        "migration(04)"=bmi2021[["5"]][2,6],
        "migration(05)"=bmi2021[["5"]][3,6],
        "migration(06-07)"=NA), 
    "2022"=c("capture (nb)"=0,
        "capture (kg)"=0,
        "migration(03)"=bmi2022[["5"]][1,6],
        "migration(04)"=bmi2022[["5"]][2,6],
        "migration(05)"=bmi2022[["5"]][3,6],
        "migration(06-07)"=NA) 
)
save(datmens, file=str_c(datawdy,"datmens.Rdata"))



#########################
# Tableau des effectifs mensuels
###########################
#load(file=str_c(datawdy,"datmens.Rdata"))
datmens2 <- as.data.frame(t(datmens))
rownames(datmens2) <- gsub("X","",rownames(datmens2))
xtala <- xtable(datmens2,
    caption=str_c("Migrations mensuelles et captures annuelles des aloses dans la passe à bassins 
            du barrage d'Arzal entre 2016 et ", CY,"."),
    label="table_ala_mois",
    digits=c(0,0,0,0,0,0,0),
    align =c("l","l","r","r","r","r","r"),
    display = c("s","f","f","f", "f", "f","f"))
path_y <- file.path(tabwdy,str_c("2055_IND_11_2016_",CY,".tex"))
print(xtala,
    file=path_y,
    add.to.row= list(pos=list(0),
        command=				
            "Année & \\multicolumn{2}{c}{Captures} & \\multicolumn{4}{c}{Migration} \\\\
            & nb & kg & mars & avril & mai & juin-juillet  \\\\
            "),
    include.rownames = TRUE,
    include.colnames = FALSE,		
    format.args = list(big.mark = " ", decimal.mark = ","),
    table.placement=c("pbt"),
    booktabs=TRUE)

vvv[["ALA"]][["path_y"]]<-gsub("C:/workspace/","../../../",path_y)
save(vvv, file=str_c(datawdy,"vvv.Rdata"))

# => 55 cm
# individus par tonne 520
# Effectif capturé
#dat=data.frame("annee"=2012:2015,"capture"=c(4112,4993,4105,2617),"migration"=c(423,327,293,390))
# 714 au lieu de 640
#sum(datpech2017$capture)/1000 #

#############################
# Graphique interannuel des taux d'exploitations
#############################


dat <- data.frame("annee"=2002:2022,
    "effectif_capture"=c(177,127,60,293,360,93,134,82,549,376,2499,2994,2633,1330,271,1009,0,0,0,0),
    "poids_capture"=c(rep(NA,10),4112,4993,4105,2617,456,1707,0,0,0,0))
dat$poids_capture/dat$effectif_capture
#dat$effectif_capture=round(1000*dat$capture/poids)
# Il ne semble pas que le poids moyen ait augmenté à Arzal en 2015
dat$effectif_capture[dat$annee==2015]=round(1000*dat$poids_capture/poids)[dat$annee==2015]
#nb<-read.table(str_c(datawd,"aloses.csv"),sep=";",header=TRUE)
load(file=str_c(datawdy,"ra_mup_",CY,".Rdata"))
nb <- ra@data[,c("annee", "effectif")]
colnames(nb)<-c("annee","migration")
#nb$migration<-nb$effectif_extrapole
#nb<-nb[,c(1,4)]
ala<-merge(nb,dat,by="annee",all.x=TRUE)
ala$effectif_total=ala$effectif_capture+ala$migration
ala$tx_exploitation=str_c(round(100*ala$effectif_capture/ala$effectif_total,0),"%")
ala$poids_moy<-ala$poids_capture/ala$effectif_capture
load_package("reshape2")
ala2<-melt(ala[c("annee","migration","effectif_capture")],id.vars=c("annee"),variable.name ="source",value.name="effectif")
library(ggplot2)
ala$textpos<-ala$effectif_total+100
#load_package(ggthemr)
#ggthemr("camouflage", type="outer", layout="scientific", spacing=0.8)
#ggthemr_reset()
str(ala2)
ala2$source<-as.character(ala2$source)
#####################
# graphs for presentation
######################
# first graph with no capture
ala0 <- ala2
ala0$effectif[ala0$source=="effectif_capture"] <- 0

# Graphiques sequentiels

png(file=str_c(imgwdy,"tx_exploit0.png"),15,10,units="cm",res=300)
g<-ggplot(ala0[ala0$annee<=2001,])+geom_bar(aes(x=annee,y=effectif,fill=source),stat="identity")+ylim(0,5000)+
    scale_fill_manual("source",values=c("migration"="#453B1A","effectif_capture"="#93853F"))+
    scale_x_continuous(limits=c(1995,2015))+
    theme(#text= element_text(size = 12, colour = 'white'),
        legend.box =NULL,
        #legend.key = element_rect(colour = NA, fill = 'white'),
        #legend.text = element_text(size = 12, colour = 'black'), 
        #legend.background = element_rect(colour = NA, fill = 'white'),
        legend.position = c(.2, .8))
print(g)
dev.off()

#png(file=str_c(imgwdy,"tx_exploit1.png"),15,10,units="cm",res=300)
#g<-ggplot(ala0[ala0$annee<=2011,])+geom_bar(aes(x=annee,y=effectif,fill=source),stat="identity")+ylim(0,5000)+
#		scale_fill_manual("source",values=c("migration"=bleu_EV,"effectif_capture"=orange_EV))+
#		scale_x_continuous(limits=c(1995,2015)) +
#		theme_bw() +
#		theme(#text= element_text(size = 12, colour = 'white'),
#				legend.box =NULL,
#				#legend.key = element_rect(colour = NA, fill = 'white'),
#				#legend.text = element_text(size = 12, colour = 'black'), 
#				#legend.background = element_rect(colour = NA, fill = 'white'),
#				legend.position = c(.2, .8))
#print(g)
#dev.off()

#png(file=str_c(imgwdy,"tx_exploit2.png"),15,10,units="cm",res=300)
#g<-ggplot(ala0[,])+geom_bar(aes(x=annee,y=effectif,fill=source),stat="identity")+ylim(0,5000)+
#		scale_fill_manual("source",values=c("migration"=bleu_EV,"effectif_capture"=orange_EV))+
#		scale_x_continuous(limits=c(1995,2015)) +
#		theme_bw() +		
#		theme(#text= element_text(size = 12, colour = 'white'),
#				legend.box =NULL,
#				#legend.key = element_rect(colour = NA, fill = 'white'),
#				#legend.text = element_text(size = 12, colour = 'black'), 
#				#legend.background = element_rect(colour = NA, fill = 'white'),
#				legend.position = c(.2, .8))
#print(g)
#dev.off()

png(file=str_c(imgwdy,"tx_exploit3.png"),15,10,units="cm",res=300)
g<-ggplot(ala2)+geom_bar(aes(x=annee,y=effectif,fill=source),stat="identity")+ylim(0,5000)+
    scale_fill_manual("source",values=c("migration"=bleu_EV,"effectif_capture"=orange_EV))+
    geom_text(aes(x=annee,y=textpos,label=tx_exploitation),data=ala[ala$annee<=CY,],size=3)+
    scale_x_continuous(limits=c(1995,CY+1)) +
    theme_bw() +		
    theme(#text= element_text(size = 12, colour = 'white'),
        legend.box =NULL,
        #legend.key = element_rect(colour = NA, fill = 'white'),
        #legend.text = element_text(size = 12, colour = 'black'), 
        #legend.background = element_rect(colour = NA, fill = 'white'),
        legend.position = c(.2, .8))
print(g)

dev.off()
png(file=str_c(imgwdy,"tx_exploit.png"),15,10,units="cm",res=300)
g<-ggplot(ala2)+geom_bar(aes(x=annee,y=effectif,fill=source),stat="identity")+ylim(0,5000)+
    scale_fill_manual("source",values=c("migration"=bleu_EV,"effectif_capture"=orange_EV))+
    geom_text(aes(x=annee,y=textpos,label=tx_exploitation),data=ala,size=3) +
    theme_bw() +
    theme(#text= element_text(size = 12, colour = 'white'),
        legend.box =NULL,
        #legend.key = element_rect(colour = NA, fill = 'white'),
        #legend.text = element_text(size = 12, colour = 'black'), 
        #legend.background = element_rect(colour = NA, fill = 'white'),
        legend.position = c(.2, .8))
print(g)

dev.off()
# Données historiques sur l'Alose
#dat19=data.frame("annee"=c(1885,1887:1896),source="effectif_capture","effectif"=c(2440,1480,500,790,1090,814,870,372,53,44,10),"migration"=NA)
#x11()
#ggplot(dat19)+geom_bar(aes(x=annee,y=effectif,fill=source),stat="identity")+
#		scale_fill_manual("source",values=c("migration"="black","effectif_capture"="grey"))+
#		theme_bw()
#
#
##delta_t_ana=0.33
##delta_t_mar=4.33
###Ry(t)=rep(10,20)
##
##Zmar=-log(Nt)
##Rpred=alpha3*N^d/(beta3^d+N^d)
#
#ala<-rbind(ala[1:5,],ala)
#ala$annee<-1991:2022
len <- length(ala$annee)
#ala$migration[1:5]<-0
#mean(ala$migration[6:7]) # 111
#ala$Vilaine<-ala$migration-100
#ala$effectif_total=rowSums(ala[,c("effectif_capture","migration")],na.rm=TRUE)
#ala$juvenile<-NA
#ala$juvenile[1:(len-5)]<-ala$effectif_total[6:len]/exp(-4.33*0.7)
#plot(ala$effectif_total[6:len],ala$juvenile[6:len])
#text(ala$effectif_total[6:len],ala$juvenile[6:len],ala$annee[6:len],cex=0.8,pos=3)
#
#open_in_excel <- function(some_df){
#	tFile<-paste("C:/temp/",gsub("\\\\","",tempfile(fileext=paste0(substitute(some_df), ".csv"),tmpdir="")),sep="")
#	write.table(some_df, tFile, row.names=F, sep=";", quote=F)
#	system(paste('open -a \"/ProgramData/Microsoft/Windows/Start Menu/Programs/Microsoft Office/Microsoft Excel 2010\"', tFile))
#}
#
#open_in_excel(ala)
##Beverton
##R=alphaN/(beta+N)
#alpha=30993# pente à l'originie
#beta= 53      #half asymptotic rec
#par=c(alpha,beta)
#load_package("Rsolnp")
#stray=100
#beverton<-function(par,N){
#	R=par[1]*N/(par[2]+N)
#	return(R)
#}
## on calcule la différence entre le recrutement prevu par beverton
## sachant que le recrutement total est composé d'ind venant de vilaine
## et de errants (stray). Plus la part des errants est forte, plus la contribution
## des poissons de Vilaine est faible
#a_optimiser = function(par,N,R,stray)
#{
#	return(sum((beverton(par,N) +stray/exp(-4.33*0.7)- R)^2,na.rm=TRUE))
#}
#
#beverton(par,ala$effectif_total)
#############################################
#Hypothèses sur le stock historique
###########################################
#50000 ou 100000 géniteurs
Btarget=50000 # 50 000
Blim=0.3*50000
Blow=2000
seq(0,50000,by=500)
txtarget=0.6
Ftarget=-log(txtarget) # 0.51
Flim=0.7
Zmar=0.8 # Rougier et al, 2012
datatheo<-data.frame(B=seq(0,50000,by=100))
datatheo$F<-0
datatheo$tx<-0
pente<-txtarget/(Blim-Blow)
datatheo<-within(datatheo,tx[B>Blow&B<Blim]<-pente*(B-Blow)[B>Blow&B<Blim])
datatheo<-within(datatheo,tx[B>=Blim]<-txtarget)
datatheo<-within(datatheo, C<-B*tx)
par(bg = "white",col.axis="black",col.lab="black",mar=c(5.1,4.1,1,1))
with(datatheo,plot(C~B,xlab="biomasse de geniteurs",ylab="capture autorisee",type="n",cex=1.5, bty='l'))
rect(0, 0, 50000, 30000,col ="white")
with(datatheo,lines(C~B,xlab="biomasse de geniteurs",ylab="capture autorisee",type="l",lwd=2, bty='l',col="black"))
abline(a=0,b=txtarget,lty=3,col=bleu_EV)
segments(x0=2000,y0=0,x1=2000,y1=15000,col="red3",lty=2)
text(x=4000,y=15000,labels="Blow",col="red3")
segments(x0=15000,y0=0,x1=15000,y1=15000,col=orange_EV,lty=2)
text(x=17000,y=15000,labels="Blim",col=orange_EV)
#############################################
#Diagramme de précaution
###########################################
background<-function(Aminimum=0,Amaximum=4,Bminimum=0,Bmaximum=100000){
# the left of the graph is filled with polygons
  Bminimum<<-Bminimum
  Bmaximum<<-Bmaximum
  Amaximum<<-Amaximum
  Atarget<--log(txtarget)
  Blim=15000
  Btrigger=Blim
  Blow=2000
  B<-c(Bminimum,Blow,Blim)
  SumA<-c(Aminimum,Aminimum,Atarget) # linear decrease in proportion to B/Btrigger
  X<-c(B,rev(B))
  Ylowersquare<-c(SumA,rep(Aminimum,length(B)))
  df<-data.frame("B"=X,"SumA"=Ylowersquare,"color"="orange3")
  Yuppersquare<-c(SumA,rep(Amaximum,length(B)))
  df<-rbind(df,	data.frame("B"=X,"SumA"=Yuppersquare,"color"="red3"))
  df<-rbind(df,data.frame("B"=c(Blim,Blim,Bmaximum,Bmaximum),
          "SumA"=c(Aminimum,Atarget,Atarget,Aminimum),
          "color"="palegreen3")) # drawn clockwise from low left corner
  df<-rbind(df,data.frame("B"=c(Blim,Blim,Bmaximum,Bmaximum,Blim),
          "SumA"=c(Atarget,Amaximum,Amaximum,Atarget, Atarget),
          "color"="orange3")) # drawn clockwise from low left corner
  return(df)
}
######################"
# Data for buble plot (must be in the same format)
############################
Aminimum=0;Amaximum=1;Bminimum=1;Bmaximum=20000
df<-background(Aminimum,Amaximum,Bminimum,Bmaximum)
# Building the graph
# http://had.co.nz/ggplot2/
#symbol() =>adobe family  http://www.stat.auckland.ac.nz/~paul/R/CM/AdobeSym.html
#italic() => en italique
#tapper demo(plotmath) for list of possible formats
precodataf <- ala[12:len,c("annee","effectif_total","tx_exploitation")]
precodataf$tx_exploitation<-as.numeric(gsub("%","",precodataf$tx_exploitation))/100
precodataf$A=-log(precodataf[,"tx_exploitation"])
load_package("ggrepel")
# All labels should be to the right of 3.
x_limitsu <- c(5000, NA)
x_limitsl <- c(NA, 1000)

g <-	ggplot(df[,]) +
    theme_bw()+		
    theme(legend.key = element_rect(colour = "white")) +
    geom_polygon(aes(x=B,y=SumA,fill=color),alpha=0.7) +		
    scale_fill_identity(labels=NULL) +
    scale_x_continuous(name=expression(paste(bold("Nombre geniteurs"))),
        limits=c(Bminimum, Bmaximum),
        breaks=c(1,2000,15000,20000),
        labels=c(1,2000,15000,20000)) +
    scale_y_continuous(name=expression(paste(bold("Mortalite cumulee")~ ~symbol("\123"),"A")),
        limits=c(Aminimum, Amaximum)) +			
    #scale_colour_discrete(name="year")+	
    #scale_color_discrete(guide = 'none')+
    geom_path(data=precodataf,aes(x=effectif_total,y=tx_exploitation,col=annee),size=1.5)+
    geom_point(data=precodataf,aes(x=effectif_total,y=tx_exploitation,size=effectif_total), 
        colour="black", 
        pch=21,
        fill="yellow")	+
    
    geom_label_repel(data=precodataf[precodataf$effectif_total>2000,],
        aes(x=effectif_total,y=tx_exploitation, 
            label = annee),
        arrow = grid::arrow(length = unit(0.01, "npc"), type = "closed", ends = "last"),
        force = 1,
        xlim  = x_limitsu) +
    geom_label_repel(data=precodataf[precodataf$effectif_total<=2000,],
        aes(x=effectif_total,y=tx_exploitation, 
            label = annee),
        arrow = grid::arrow(length = unit(0.01, "npc"), type = "closed", ends = "last"),
        force = 1,
        xlim  = x_limitsl      
    ) +
    scale_colour_continuous(trans = 'reverse')

png(file=str_c(imgwdy,"preco_diagram.png"),10,7,units="in",res=300)
print(g)
dev.off()
#      		annotate("text",x=precodataf$effectif_total,y=precodataf$tx_exploitation,
#				label=precodataf$annee,size=4,hjust=-0.5,color="black")+

#		theme(text= element_text(size = 14, colour = 'black'))


#####################################################################
# Optimisation
##################################################################
#load_package("bootstrap")
#stray=0
#res<-solnp(pars = par, fun = function(x) a_optimiser(x, ala$effectif_total,ala$juvenile,
#					stray=stray),  control = list(trace = 6))
#par=res$pars
#points(1:4000,beverton(par,1:4000),type="l",col="orange")
#text(4500, 55900,"stray=0",col="orange")
#stray=100
#res<-solnp(pars = par, fun = function(x) a_optimiser(x, ala$effectif_total,ala$juvenile,stray=stray),  control = list(trace = 6))
#par=res$pars
#points(1:4000,beverton(par,1:4000),type="l",col="orange")
#text(4500, 53230,"stray=100",col="orange")
#stray=500
#res<-solnp(pars = par, fun = function(x) a_optimiser(x, ala$effectif_total,ala$juvenile,stray=stray),  control = list(trace = 6))
#par=res$pars
#points(1:4000,beverton(par,1:4000),type="l",col="orange")
#text(4500, 45000,"stray=500",col="orange")
#function_boot<-function(d,ind,col){
#	alpha=1000# pente à l'originie
#	beta= 53      #half asymptotic rec
#	par=c(alpha,beta)
#	res<-solnp(pars = par, fun = function(x) a_optimiser(x, d[ind,"effectif_total"],d[ind,"juvenile"],stray=stray), LB=c(0,0),UB=c(100000,100000), control = list(trace = 6))
#	par=res$pars
#	if (res$pars[])
#		points(1:4000,beverton(par,1:4000),type="l",col=col)
#	return(res$pars)
#}
#par(col.axis="antiquewhite")
#plot(ala$effectif_total[6:25],ala$juvenile[6:25],
#		xlab=iconv("Spawning stock number","UTF8"),
#		ylab=iconv("Juvéniles sum(Z)=3","UTF8"),
#		xlim=c(0,6000),
#		col="white",
#		pch=16,
#		col.axis="antiquewhite"
#)
#box(col="white")
#axis(side=1,col="white")
#axis(side=2,col="white")
##text(ala$effectif_total[6:25],ala$juvenile[6:25],ala$annee[6:25],cex=0.8,pos=3)
#stray=0
#bo<-boot(ala,function_boot,R=200,col="yellow")
##stray=100
##bo<-boot(ala,function_boot,R=50,col="orange")
##stray=200
##bo<-boot(ala,function_boot,R=50,col="purple")
#points(ala$effectif_total[6:25],ala$juvenile[6:25]+stray,
#		cex=2,pch=19)
#
#function_boot(ala,c(6,12,13,14,19,20),col="purple")
#points(ala$effectif_total[c(6,12,13,20)],ala$juvenile[c(6,12,13,20)]+stray,
#		pch=19,col="purple")
#text(ala$effectif_total[6:25]+200,ala$juvenile[6:25]+2000,ala$annee[6:25])
#beverton(c(40951,310),40000)/2
#c(1:4000)[which(beverton(c(40951,310),1:4000)>beverton(c(40951,310),40000)/2)][1]
#abline(v=306,col="purple")
#
#points(1:4000,c(1:4000)/exp(-4.33*0.7),type="l")

@


\clearpage
\twocolumn
\subsection{Saumon}
%\vspace{5pt} % utiliser innertopmargin
\makebox[-2.5pt]{
  \begin{tikzpicture}[overlay]
  \node[inner sep=0pt] (alose) at (150pt,30pt)
      {
      \begin{turn}{0}
      \includegraphics[width=.12\textwidth]{Salmo_salar.jpg}
      \end{turn}
      };
  \node[inner sep=0pt] (status) at (100pt,28pt)
      {
      \includegraphics[width=0.5cm]{VU.jpg}
      };    
  \end{tikzpicture}
}
\fbox{\begin{minipage}[t]{0.45\textwidth}
\par\small
\titlefont\textcolor{bleu_EV}{
Le saumon atlantique \textit{Salmo salar} est un poisson migrateur amphihalin,
qui ne se reproduit généralement qu'une seule fois.
La reproduction a lieu en eau douce en novembre-janvier, avec un homing fort. 
Le jeune saumon (tacon) y reste 1 à 2 ans avant de se métamorphoser en smolt qui dévale 
au printemps vers la mer pour une phase de croissance de 1 an (saumon de printemps) à 3 ans
(saumon d'hiver). En général, la durée du séjour marin dépend de la rivière de retour : 
plus la migration en eau douce sera longue, plus le saumon devra rester en
mer pour accumuler des réserves qui lui permettront d'atteindre les frayères.
En Bretagne, l'espèce est bien présente, dans la majorité des cours d'eau à
l'exception de la Vilaine.
Certaines rivières sont bien fréquentées, à l'image du Blavet et de l'Aulne. 
Si historiquement la Vilaine accueillait beaucoup de saumons, les migrations 
sont aujourd'hui très faibles.
L'espèce est classée vulnérable en France sur la liste rouge UICN.
}
\end{minipage}}
\smallskip

\Sexpr{vvv$SAT$N[vvv$SAT$N$annee==CY,"effectif"]} saumons ont été comptés en
\Sexpr{CY} (Figure \ref{barplot_report_annual_sat},  Tableau \ref{table_sat_mois}).
Cette migration place l'année \Sexpr{CY} au \Sexpr{vvv$SAT$rank} ème rang
par rapport à l'ensemble des années de migration (Figures
\ref{table_bilanannuel_sat}, Tableau \ref{barchart_bmi_sat}).

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/barplot_report_annual_sat.png} 
\caption{Histogramme des effectifs annuels de saumons comptabilisés
au barrage d'Arzal.}
\label{barplot_report_annual_sat}
\end{figure}

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/barchart_bmi_sat.png} 
\caption{Comparaison de la migration de saumons de \Sexpr{CY} avec la
série interannuelle de données 1996-\Sexpr{CY-1}.}
\label{barchart_bmi_sat}
\end{figure}

\input{\Sexpr{vvv[["SAT"]][["path_y"]]}} % table bilan annuel 

\input{\Sexpr{vvv[["SAT"]][["path"]]}} % table bilan lamproies pour l'année

La migration des saumons intervient toute l'année avec un pic estival (Figure
\ref{rmi_density_sat}). En \Sexpr{CY}, la migration s'est faite principalement
en juillet (Figure \ref{barchart_bmi_sat}).

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/rmi_density_sat.png} 
\caption{Saisonnalité des migrations de saumons atlantiques sur la Vilaine.}
\label{rmi_density_sat}
\end{figure}


Les tailles des saumons mesurées au niveau de la passe d'Arzal sont présentées
en Figure \ref{size_sat}.

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/size_sat.png} 
\caption{Taille des saumons mesurés au niveau du dispositif de vidéocontrôle
d'Arzal.}
\label{size_sat}
\end{figure}

<<report_mig_mult_sat, echo=FALSE, eval=FALSE,include=FALSE >>=
color_ope<-sample(c(mycolorramp1(10),mycolorramp2(10)),20)
bMM_Arzal <- new("report_mig_mult")
bMM_Arzal <- choice_c(bMM_Arzal,
    dc=c(5),
    taxa=c("Salmo salar"),
    stage=c("IND"),
    datedebut=str_c(CY,"-01-01"),
    datefin=str_c(CY,"-12-31"))
bMM_Arzal<-charge(bMM_Arzal)
bMM_Arzal<-connect(bMM_Arzal)
bMM_Arzal=calcule(bMM_Arzal)

png(file=str_c(imgwdy,"bmm_sat.png"),7,7,units="in",res=300)
plot(bMM_Arzal,plot.type="standard",
    color=color,
    color_ope=color_ope,
    main=str_c("Effectif de saumons en ", CY),
    cex.main=1.1,		
    type="h",
    silent=TRUE)
dev.off()
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<report_interannual_sat, echo=FALSE, eval=FALSE, include=FALSE >>=
rmi <- new("report_mig_interannual")
rmi <- choice_c(rmi,
    dc=c(5),
    taxa=c("Salmo salar"),
    stage=c("IND"),
    start_year="1996",
    end_year=CY,
    silent=TRUE)
rmi <- charge(rmi)
rmi <- connect(rmi,check=TRUE,silent=FALSE)	
rmi <- calcule(rmi)

# utilisation de la méthode plot pour générer un graphique des densités
# puis modification des couleurs du titre et de y
plot(rmi,plot.type="density",silent=TRUE)
g <- get("g",envir=envir_stacomi)
nb_annee<-length(unique(rmi@data$bjo_annee))
mycolorramp <- colorRampPalette(c('#020731','#3862C6','#6E7587','#806641','#AE956D'))

colors<-rev(mycolorramp(nb_annee))
#============================================
png(filename=str_c(imgwdy,"rmi_density_sat.png"))
g+ggplot2::scale_fill_manual(values=colors)+
    ggplot2::ggtitle("")+
    theme(
        panel.border = element_blank(),
        panel.background = element_blank(),
        panel.grid.minor = element_line(colour = "white"),
        panel.grid.major = element_line(colour = "white"),
        panel.grid.major.x = element_line(colour = "white"))
dev.off()
#============================================
plot(rmi,plot.type="barchart",timesplit="mois",silent=TRUE)
g <- get("g1",envir=envir_stacomi)
cols <- c("max" = "#012746","min" = "#6C3E00",">=moy" = "#327AB5", "<moy" = "#D29035","hist_mean"="black","hist_range"="grey","?"="#D26435")
fills <- c("max" = "#043C6B","min" = "#6C3E00",">=moy" = "#558AB5", "<moy" = "#D2A25F","hist_mean"="black","hist_range"="grey","?"="#D26435")
g <- g+scale_colour_manual(name=CY,values=cols,limits=c("min","max","<moy",">=moy","hist_mean","hist_range","?"))
g <- g+scale_fill_manual(name=CY,values=fills,limits=c("min","max","<moy",">=moy","hist_mean","hist_range","?"))
g <- g+ggtitle("")
#============================================
png(filename=str_c(imgwdy,"barchart_bmi_sat.png"))
print(g)
dev.off()
#============================================
#png(filename=str_c(imgwdy,"plot_seasonal_sat.png"),width=14,height=10,unit="cm",res=300)
#plot(rmi,plot.type="seasonal",timesplit="semaine") 
#dev.off()

# ====== Bilan mensuel ===============

mmm <- summary(rmi,silent=TRUE)$'5' 
mmm <- mmm[,-1]
colnames(mmm) <- c("Mois", "Min*", "Moyenne*", "Max*", "N (2022)")
xtmmm<-xtable(mmm,caption="Migrations mensuelles des saumons dans la passe à bassins du barrage d'Arzal, $N$ nombre, * correspondent à
        la période 1996-2022. min* minimum mensuel, max* maximum mensuel, moyenne* moyenne des effectifs mensuels.",
    label="table_sat_mois",
    digits=c(0,0,0,0,0,0),
    display = c("s","s","f","f", "f", "f"))
path_y=file.path(tabwdy,
    paste(5,"_",
        paste(rmi@taxa@taxa_selected,collapse="_"),"_",
        paste(rmi@stage@stage_selected,collapse="_"),"_"
        ,"mensuel.tex",sep=""),fsep ="")
print(xtmmm,
    file=path_y,
    format.args = list(big.mark = " ", decimal.mark = ","),
    table.placement=c("htbp")#,
#include.rownames = FALSE => OK set as global options
)
#vvv[["LPM"]]<- list()# normalement vient du rapport de l'années précédente
vvv[["SAT"]][["path_y"]]<-gsub("C:/workspace/","../../../",path_y)
save(vvv,file=str_c(datawdy,"vvv.Rdata"))
@


<<report_annual_sat, echo=FALSE, eval=FALSE,include=FALSE >>=
###############################
# Bilan annuel des migrations
###############################
ra <- new("report_annual")
ra <- choice_c(ra,
    dc=c(5),
    taxa=c("Salmo salar"),
    stage=c("IND"),
    start_year=1996,
    end_year=CY,
    silent=TRUE)
ra <- connect(ra,silent=FALSE)
png(filename=str_c(imgwdy,"barplot_report_annual_sat.png"))
barplot(ra)
dev.off()
xtra<-stacomiR::xtable(ra,
    caption="Migration des saumons atlantiques dans la passe à bassins du barrage
        d'Arzal (passe à fentes verticales).",
    label="table_bilanannuel_sat",
    dc_name=c("P. bassins")		
)
# below not run but one can create a file as following

path <- file.path(tabwdy,
    paste(paste(ra@dc@dc_selected,collapse="_"),"_",
        paste(ra@taxa@taxa_selected,collapse="_"),"_",
        paste(ra@stage@stage_selected,collapse="_"),"_",
        ra@start_year@year_selected,"to",
        ra@end_year@year_selected,".tex",sep=""),fsep ="")
# the following uses the "addtorow" argument which creates nice column headings,
# format.args creates a thousand separator
# again this will need to be saved in a file using the file argument
print(xtra,
    file=path,
    add.to.row= list(pos=list(0),
        command=				
            "\\multicolumn{2}{c}{\\textit{saumon}}  \\\\
            \\multicolumn{2}{c}{Indéterminé} \\\\"),		
    include.rownames = TRUE,
    include.colnames = FALSE,
    format.args = list(big.mark = " ", decimal.mark = ","),
    booktabs=TRUE
)

# some manual editing needed....
#===================================================
png(filename=str_c(imgwdy,"bilan_annuel_sat.png"))
barplot(ra,args.legend=list(x="topleft",bty = "n"),
    col=c(marron),
    ylab="Effectif (saumons atlantiques)")
dev.off()
#===================================================
# total 


vvv[["SAT"]][["path"]] <- gsub("C:/workspace/","../../../",path)

somme <- round(tapply(ra@data$effectif,ra@data$annee,sum))
indiceCY <- match(as.character(CY),names(somme))
vvv[["SAT"]][["N"]] <- as.data.frame(ra@data[,c(1,2)])
vvv[["SAT"]][["NCY"]] <- somme[indiceCY]

vvv[["SAT"]][["rank"]] <- nrow(somme)+1-rank(somme)[indiceCY]
vvv[["SAT"]][["maxrank"]] <- nrow(somme)
save(vvv,file=str_c(datawdy,"vvv.Rdata"))
@

<<report_sample_char_sat, echo=FALSE, eval=FALSE,include=FALSE >>=
library("stacomiR")

# launching stacomi without selecting the scheme or interface
stacomi()
# TODO AJOUTER LES SALMO
r_sample_char <- new("report_sample_char")
r_sample_char <- choice_c(r_sample_char,
    dc=c("5"),
    taxa=c("Salmo salar"),
    stage=c("IND"),
    par=c("C001"),
    horodatedebut="1998-01-01",
    horodatefin=str_c(CY,"-12-31"),
    silent=FALSE)
r_sample_char <- connect(r_sample_char)
r_sample_char <- calcule(r_sample_char,silent=TRUE)



png(filename=str_c(imgwdy,"size_sat.png"))
ggplot(r_sample_char@data) +
    geom_boxplot(aes(x=annee,y=car_valeur_quantitatif), outlier.alpha = 0) +
    ggplot2::ylab("taille video (mm)")+
    ggplot2::xlab("annee")+
    geom_jitter(aes(x=annee,y=car_valeur_quantitatif),col=bleu_EV,
        width = 0.2, 
        height = 0.2, 
        alpha=0.5)+
    theme_bw() 
dev.off()
@


<<report_interannual_trt, echo=FALSE, eval=FALSE, include=FALSE >>=
# les trt sont traduites en Salmo au niveau genre dans la base : essais pour comprendre
rmi <- new("report_mig_interannual")
rmi <- choice_c(rmi,
    dc=c(5),
    taxa=c("Salmo"),
    stage=c("IND"),
    start_year="1996",
    end_year=CY,
    silent=TRUE)
rmi <- charge(rmi)
rmi <- connect(rmi,check=TRUE,silent=FALSE)	
rmi <- calcule(rmi)

# utilisation de la méthode plot pour générer un graphique des densités
# puis modification des couleurs du titre et de y
plot(rmi,plot.type="density",silent=TRUE)
g <- get("g",envir=envir_stacomi)
nb_annee<-length(unique(rmi@data$bjo_annee))
mycolorramp <- colorRampPalette(c('#020731','#3862C6','#6E7587','#806641','#AE956D'))

colors<-rev(mycolorramp(nb_annee))
#============================================
png(filename=str_c(imgwdy,"rmi_density_trt.png"))
g+ggplot2::scale_fill_manual(values=colors)+
    ggplot2::ggtitle("")+
    theme(
        panel.border = element_blank(),
        panel.background = element_blank(),
        panel.grid.minor = element_line(colour = "white"),
        panel.grid.major = element_line(colour = "white"),
        panel.grid.major.x = element_line(colour = "white"))
dev.off()
#============================================
plot(rmi,plot.type="barchart",timesplit="mois",silent=TRUE)
g <- get("g1",envir=envir_stacomi)
cols <- c("max" = "#012746","min" = "#6C3E00",">=moy" = "#327AB5", "<moy" = "#D29035","hist_mean"="black","hist_range"="grey","?"="#D26435")
fills <- c("max" = "#043C6B","min" = "#6C3E00",">=moy" = "#558AB5", "<moy" = "#D2A25F","hist_mean"="black","hist_range"="grey","?"="#D26435")
g <- g+scale_colour_manual(name=CY,values=cols,limits=c("min","max","<moy",">=moy","hist_mean","hist_range","?"))
g <- g+scale_fill_manual(name=CY,values=fills,limits=c("min","max","<moy",">=moy","hist_mean","hist_range","?"))
g <- g+ggtitle("")
#============================================
png(filename=str_c(imgwdy,"barchart_bmi_trt.png"))
print(g)
dev.off()
#============================================
#png(filename=str_c(imgwdy,"plot_seasonal_sat.png"),width=14,height=10,unit="cm",res=300)
#plot(rmi,plot.type="seasonal",timesplit="semaine") 
#dev.off()

# ====== Bilan mensuel ===============

mmm <- summary(rmi,silent=TRUE)$'5' 
mmm <- mmm[,-1]
colnames(mmm) <- c("Mois", "Min*", "Moyenne*", "Max*", "N (2022)")
xtmmm<-xtable(mmm,caption="Migrations mensuelles de truites dans la passe à bassins du barrage d'Arzal, $N$ nombre, * correspondent à
        la période 1996-2022. min* minimum mensuel, max* maximum mensuel, moyenne* moyenne des effectifs mensuels.",
    label="table_sat_genre_mois",
    digits=c(0,0,0,0,0,0),
    display = c("s","s","f","f", "f", "f"))
path_y=file.path(tabwdy,
    paste(5,"_",
        paste(rmi@taxa@taxa_selected,collapse="_"),"_",
        paste(rmi@stage@stage_selected,collapse="_"),"_"
        ,"mensuel.tex",sep=""),fsep ="")
print(xtmmm,
    file=path_y,
    format.args = list(big.mark = " ", decimal.mark = ","),
    table.placement=c("htbp")#,
#include.rownames = FALSE => OK set as global options
)
#vvv[["LPM"]]<- list()# normalement vient du rapport de l'années précédente
vvv[["SAT"]][["path_y"]]<-gsub("C:/workspace/","../../../",path_y)
save(vvv,file=str_c(datawdy,"vvv.Rdata"))
@



<<report_sample_char_trt, echo=FALSE, eval=FALSE,include=FALSE >>=
library("stacomiR")

# launching stacomi without selecting the scheme or interface
stacomi()
r_sample_char <- new("report_sample_char")
r_sample_char <- choice_c(r_sample_char,
    dc=c("5"),
    taxa=c("Salmo"),
    stage=c("IND"),
    par=c("C001"),
    horodatedebut="1998-01-01",
    horodatefin=str_c(CY,"-12-31"),
    silent=FALSE)
r_sample_char <- connect(r_sample_char)
r_sample_char <- calcule(r_sample_char,silent=TRUE)



png(filename=str_c(imgwdy,"size_sat.png"))
ggplot(r_sample_char@data) +
    geom_boxplot(aes(x=annee,y=car_valeur_quantitatif), outlier.alpha = 0) +
    ggplot2::ylab("taille video (mm)")+
    ggplot2::xlab("annee")+
    geom_jitter(aes(x=annee,y=car_valeur_quantitatif),col=bleu_EV,
        width = 0.2, 
        height = 0.2, 
        alpha=0.5)+
    theme_bw() 
dev.off()
@





\clearpage
\subsection{Truite de mer}
%\vspace{5pt} % utiliser innertopmargin
\makebox[-2pt]{
  \begin{tikzpicture}[overlay]
  \node[inner sep=0pt] (trm) at (150pt,20pt)
      {
      \begin{turn}{0}
      \includegraphics[width=.15\textwidth]{salmo_trutta_trutta.jpg}
      \end{turn}
      };
  \node[inner sep=0pt] (status) at (100pt,18pt)
      {
      \includegraphics[width=0.5cm]{NT.jpg}
      };        
  \end{tikzpicture}
}%

\fbox{\begin{minipage}[t]{0.45\textwidth}
\par\small
\textcolor{bleu_EV}{
\titlefont{
La truite de mer \textit{Salmo trutta trutta} est un poisson migrateur
amphihalin qui se reproduit souvent plusieurs fois.
La reproduction a lieu en eau douce en novembre-janvier, avec un homing assez fort.
Environ 1/4 des truites de mer, majoritairement des mâles, seront sédentaires, 
les autres, majoritairement des femelles, dévaleront après 1 à 2 ans de vie en eau douce. 
Le séjour marin s'effectue à proximité des côtes françaises, avec des incursions fréquentes en eau douce. 
La durée de la phase marine est très variable, de quelques mois à 3 ans.
Les adultes de cette espèce peuvent rester en rivière, aller grossir en mer ou grossir 
en lac selon les contextes, ce qui définit trois écotypes distincts (truite fario, truite de mer et truite 
lacustre). La truite est classée en statut quasi menacé (NT) en France sur la
liste rouge UICN, il n'y a pas de classement pour les truites de mer mais elles sont
peu présente en Bretagne.
Sur la Vilaine, des alevinages de truites ont provoqué le passage d'environ 400 truites de mer en 1996,
puis les effectifs ont chuté très rapidement, pour être anecdotiques ces dernières années.
}}
\end{minipage}}
\smallskip

%\Sexpr{vvv$TRM$N[vvv$TRM$N$annee==CY,"effectif"]} 
Aucune truites de mer n'a été %ont été
comptée en \Sexpr{CY} (Figure \ref{barplot_report_annual_trm}) %,  Tableau
%\ref{table_trm_mois}).
\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/barplot_report_annual_trm.png} 
\caption{Histogramme des effectifs annuels de truites de mer comptabilisés
au barrage d'Arzal.}
\label{barplot_report_annual_trm}
\end{figure}
%
%La migration est faible par rapport aux années précédentes (Figure
%\ref{table_bilanannuel_trm}, Tableau \ref{barchart_bmi_trm}).

%\begin{figure}[htpb]
%\centering
%\includegraphics[width=0.45\textwidth]{2022/barchart_bmi_trm.png} 
%\caption{Comparaison de la migration de truite de mer de \Sexpr{CY} avec la
%série interannuelle de données 1996-\Sexpr{CY-1}.}
%\label{barchart_bmi_trm}
%\end{figure}

%\input{\Sexpr{vvv[["TRM"]][["path_y"]]}} 

\input{\Sexpr{vvv[["TRM"]][["path"]]}} 

La migration des truites de mer intervient toute l'année avec un pic estival
(Figure \ref{rmi_density_trm}). 
% En \Sexpr{CY}, la migration s'est faite en juin,
% juillet août et octobre Figures (\ref{barchart_bmi_trm},
% \ref{rmi_density_trm}).

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/rmi_density_trm.png} 
\caption{Saisonnalité des migrations de truites de mer sur la Vilaine.}
\label{rmi_density_trm}
\end{figure}


Les tailles des truites mesurées au niveau de la passe d'Arzal sont présentées
en Figure \ref{size_trm}.

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/size_trm.png} 
\caption{Taille des truites de mer mesurées au niveau du dispositif de
vidéocontrôle d'Arzal.}
\label{size_trm}
\end{figure}
<<report_mig_mult_trm, echo=FALSE, eval=FALSE,include=FALSE >>=
color_ope<-sample(c(mycolorramp1(10),mycolorramp2(10)),20)
bMM_Arzal <- new("report_mig_mult")
bMM_Arzal <- choice_c(bMM_Arzal,
    dc=c(5),
    taxa=c("Salmo trutta trutta"),
    stage=c("IND"),
    datedebut=str_c(CY,"-01-01"),
    datefin=str_c(CY,"-12-31"))
bMM_Arzal <- charge(bMM_Arzal)
bMM_Arzal <- connect(bMM_Arzal)
bMM_Arzal <- calcule(bMM_Arzal)
color=c(
    "#052945",#working
    "#ECDAC0",#stopped
    "#3071A2",#normal
    "#462800",#maintenance
    "#B68B52",#dysfunction
    "#FFC26E",
    "#A66F24",
    "#012746",#mesure
    "#29A570",#calcule
    "#B67B2D", #expert
    "#4F7EA2" # ponctuel
)
if (nrow(bMM_Arzal@data)==0) {
  bM = new("report_mig")
  if (!silent)
    funout(gettextf("Running report_mig for year %s", Y, domain = "R-StacomiR"))
  bM = choice_c(
      bM,
      dc = 5,
      taxa=c("Salmo trutta trutta"),
      stage=c("IND"),
      datedebut=str_c(CY,"-01-01"),
      datefin=str_c(CY,"-12-31"))	
  bM <- charge(bM, silent = FALSE)
  bM <- connect(bM, silent = FALSE)
  bM <- calcule(bM, silent = FALSE)
  
  
  
  stop("PAs de truites de mer cette année, supprimer le graphe")
}
png(file=str_c(imgwdy,"bmm_trm.png"),7,7,units="in",res=300)
plot(bMM_Arzal,plot.type="standard",
    color=color,
    color_ope=color_ope,
    main=str_c("Effectif de truites de mer en ", CY),
    cex.main=1.1,		
    type="h",
    silent=TRUE)
dev.off()
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<report_interannual_trm, echo=FALSE, eval=FALSE, include=FALSE >>=
rmi<-new("report_mig_interannual")
rmi<-choice_c(rmi,
    dc=c(5),
    taxa=c("Salmo trutta trutta"),
    stage=c("IND"),
    start_year="1996",
    end_year=CY,
    silent=TRUE)
rmi<-charge(rmi)
rmi<-connect(rmi,check=TRUE,silent=FALSE)	
rmi<-calcule(rmi)

# utilisation de la méthode plot pour générer un graphique des densités
# puis modification des couleurs du titre et de y
plot(rmi,plot.type="density",silent=TRUE)
g<-get("g",envir=envir_stacomi)
nb_annee<-length(unique(rmi@data$bjo_annee))
mycolorramp <- colorRampPalette(c('#020731','#3862C6','#6E7587','#806641','#AE956D'))

colors<-rev(mycolorramp(nb_annee))
#============================================
png(filename=str_c(imgwdy,"rmi_density_trm.png"))
g+ggplot2::scale_fill_manual(values=colors)+
    ggplot2::ggtitle("")+
    theme(
        panel.border = element_blank(),
        panel.background = element_blank(),
        panel.grid.minor = element_line(colour = "white"),
        panel.grid.major = element_line(colour = "white"),
        panel.grid.major.x = element_line(colour = "white"))
dev.off()
#============================================
plot(rmi,plot.type="barchart",timesplit="mois",silent=TRUE)
g <- get("g1",envir=envir_stacomi)
cols <- c("max" = "#012746","min" = "#6C3E00",">=moy" = "#327AB5", "<moy" = "#D29035","hist_mean"="black","hist_range"="grey","?"="#D26435")
fills <- c("max" = "#043C6B","min" = "#6C3E00",">=moy" = "#558AB5", "<moy" = "#D2A25F","hist_mean"="black","hist_range"="grey","?"="#D26435")
g <- g+scale_colour_manual(name=CY,values=cols,limits=c("min","max","<moy",">=moy","hist_mean","hist_range","?"))
g <- g+scale_fill_manual(name=CY,values=fills,limits=c("min","max","<moy",">=moy","hist_mean","hist_range","?"))
g <- g+ggtitle("")
#============================================
png(filename=str_c(imgwdy,"barchart_bmi_trm.png"))
print(g)
dev.off()
#============================================
#png(filename=str_c(imgwdy,"plot_seasonal_trm.png"),width=14,height=10,unit="cm",res=300)
#plot(rmi,plot.type="seasonal",timesplit="semaine") 
#dev.off()

# ====== Bilan mensuel ===============

mmm <- summary(rmi,silent=TRUE)$'5' 
mmm <- mmm[,-1]
colnames(mmm) <- c("Mois", "Min*", "Moyenne*", "Max*", "N (2022)")
xtmmm<-xtable(mmm,caption="Migrations mensuelles des truites de mer dans la passe à bassins du barrage d'Arzal, $N$ nombre, * correspondent à
        la période 1996-2022. min* minimum mensuel, max* maximum mensuel, moyenne* moyenne des effectifs mensuels.",
    label="table_trm_mois",
    digits=c(0,0,0,0,0,0),
    display = c("s","s","f","f", "f", "f"))
path_y=file.path(tabwdy,
    paste(5,"_",
        paste(rmi@taxa@taxa_selected,collapse="_"),"_",
        paste(rmi@stage@stage_selected,collapse="_"),"_"
        ,"mensuel.tex",sep=""),fsep ="")
print(xtmmm,
    file=path_y,
    format.args = list(big.mark = " ", decimal.mark = ","),
    table.placement=c("htbp")#,
#include.rownames = FALSE => OK set as global options
)
#vvv[["LPM"]]<- list()# normalement vient du rapport de l'années précédente
vvv[["TRM"]][["path_y"]]<-gsub("C:/workspace/","../../../",path_y)
save(vvv,file=str_c(datawdy,"vvv.Rdata"))
@

<<report_annual_trm, echo=FALSE, eval=FALSE, include=FALSE >>=
###############################
# Bilan annuel des migrations
###############################
ra<-new("report_annual")
ra<-choice_c(ra,
    dc=c(5),
    taxa=c("Salmo trutta trutta"),
    stage=c("IND"),
    start_year=1996,
    end_year=CY,
    silent=TRUE)
ra <- connect(ra,silent=FALSE)
png(filename=str_c(imgwdy,"barplot_report_annual_trm.png"))
barplot(ra)
dev.off()
xtra<-stacomiR::xtable(ra,
    caption="Migration des truites de mer dans la passe à bassins du barrage
        d'Arzal (passe à fentes verticales).",
    label="table_bilanannuel_trm",
    dc_name=c("P. bassins")		
)
# below not run but one can create a file as following

path=file.path(tabwdy,
    paste(paste(ra@dc@dc_selected,collapse="_"),"_",
        paste(ra@taxa@taxa_selected,collapse="_"),"_",
        paste(ra@stage@stage_selected,collapse="_"),"_",
        ra@start_year@year_selected,"to",
        ra@end_year@year_selected,".tex",sep=""),fsep ="")
# the following uses the "addtorow" argument which creates nice column headings,
# format.args creates a thousand separator
# again this will need to be saved in a file using the file argument
print(xtra,
    file=path,
    add.to.row= list(pos=list(0),
        command=				
            "\\multicolumn{2}{c}{\\textit{Salmo trutta trutta}}  \\\\\n 
            \\multicolumn{2}{c}{Indéterminé} \\\\"),
    include.rownames = TRUE,
    include.colnames = FALSE,
    format.args = list(big.mark = " ", decimal.mark = ","),
    booktabs=TRUE
)

# some manual editing needed....
#===================================================
png(filename=str_c(imgwdy,"bilan_annuel_trm.png"))
barplot(ra,args.legend=list(x="topleft",bty = "n"),
    col=c(marron),
    ylab="Effectif (truite de mer)")
dev.off()
#===================================================
# total 


vvv[["TRM"]][["path"]] <- gsub("C:/workspace/","../../../",path)

somme<-round(tapply(ra@data$effectif,ra@data$annee,sum))
indiceCY <- match(as.character(CY),names(somme))
vvv[["TRM"]][["N"]] <- as.data.frame(ra@data[,c(1,2)])
vvv[["TRM"]][["NCY"]] <- somme[indiceCY]

vvv[["TRM"]][["rank"]]<-nrow(somme)+1-rank(somme)[indiceCY]
vvv[["TRM"]][["maxrank"]]<-nrow(somme)
save(vvv,file=str_c(datawdy,"vvv.Rdata"))
@

<<report_sample_char_trm, echo=FALSE, eval=FALSE,include=FALSE >>=
library("stacomiR")

# launching stacomi without selecting the scheme or interface
stacomi()

r_sample_char <- new("report_sample_char")
r_sample_char <- choice_c(r_sample_char,
    dc=c("5"),
    taxa=c("Salmo trutta trutta"),
    stage=c("IND"),
    par=c("C001"),
    horodatedebut="1998-01-01",
    horodatefin=str_c(CY,"-12-31"),
    silent=FALSE)
r_sample_char <- connect(r_sample_char)
r_sample_char <- calcule(r_sample_char,silent=TRUE)


png(file=str_c(imgwdy,"size_trm.png"),10,7,units="in",res=300)
ggplot(r_sample_char@data) +
    geom_boxplot(aes(x=annee,y=car_valeur_quantitatif, fill=tax_nom_latin), outlier.alpha = 0) +
    ggplot2::ylab("taille video (mm)")+
    ggplot2::xlab("annee")+
    geom_jitter(aes(x=annee,y=car_valeur_quantitatif, col=tax_nom_latin),
        width = 0.2, 
        height = 0.2, 
        alpha=0.5)+
    theme_bw() 
dev.off()
@

\clearpage
\subsection{Autre espèces}


Par sa situation avec le pied en eau salée et la tête en eau douce, la passe ne
rencontre que des effectifs très faibles d'autres espèces. En \Sexpr{CY} les
espèces recensées sont peu
nombreuses, silure, sandre, black bass, cyprinidés et brème (Figure
\ref{autres_especes}). 
La fréquentation des autres espèces depuis 2000 est illustrée de manière
graphique à la Figure \ref{autres_especes_2000_2022}. 

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/autres_especes.png} 
\caption{Effectif des autres espèces recensées en \Sexpr{CY} dans la passe,
\textit{Abramis brama} brème, \textit{Sander lucioperca} sandre,
\textit{Cyprinus} cyprinidés sans détermination (genre), \textit{Micropterus
salmoides} black bass à grande bouche, \textit{Silurus glanis} silure.}
\label{autres_especes}
\end{figure}



\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/autres_especes_2000_2022.png} 
\caption{Effectif des autres espèces rencontrées dans la passe d'Arzal depuis
2000.}
\label{autres_especes_2000_2022}
\end{figure}


\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/bilan_annuel_sil.png} 
\caption{Effectif des silures ayant migré par la passe d'Arzal depuis
2000.}
\label{bilan_annuel_sil}
\end{figure}

Les tailles et les effectifs des silures mesurées au niveau de la passe d'Arzal
sont en très nette augmentation Figures (\ref{size_sil}\ref{bilan_annuel_sil}) .

\begin{figure}[htpb]
\centering
\includegraphics[width=0.45\textwidth]{2022/size_sil.png} 
\caption{Taille des silures mesurés au niveau du dispositif de vidéocontrôle
d'Arzal.}
\label{size_sil}
\end{figure}


\input{\Sexpr{vvv[["SIL"]][["path"]]}} % table bilan silures


<<report_species, echo=FALSE, eval=FALSE,include=FALSE >>=
bilesp <- new("report_species")
# split is one of "none", "year", "week", "month
# first load all taxa
bilesp <- choice_c(bilesp,
    dc=c(5),
    split="none", 
    start_year="2000",
    end_year=CY,
    silent=FALSE)	
# remove Liza ramada from bilesp
taxa <- bilesp@taxa@taxa_selected
taxa <- taxa[!taxa %in% c(2183,2055,2014,2224,2038, 2220)]
bilesp <- choice_c(bilesp,
    dc=c(5),
    taxa=taxa,
    split="none", 
    start_year="2000",
    end_year=CY,
    silent=FALSE)
#bilesp<-charge(bilesp) this is used by the graphical interface
bilesp <- connect(bilesp)
bilesp <- calcule(bilesp)


#install.packages("packcircles")
library(packcircles)
bilesp@calcdata <- bilesp@calcdata[order(bilesp@calcdata$Effectif),]
packing <- circleProgressiveLayout(bilesp@calcdata$Effectif, sizetype='area')
packing$radius <- 0.95*packing$radius
data <- cbind(bilesp@calcdata, packing)
# The next step is to go from one center + a radius to the coordinates of a circle that
# is drawn by a multitude of straight lines.
dat.gg <- circleLayoutVertices(packing, npoints=50)

# Make the plot
g <- ggplot() + 		
    # Make the bubbles
    geom_polygon(data = dat.gg, aes(x, y, group = id, fill=id), colour = "black", alpha = 0.6) +
    
    # Add text in the center of each bubble + control its size
    ggrepel::geom_label_repel(data = data, aes(x, y, label = paste(taxa_stage, "\n N=", Effectif)),max.overlaps = 1000) +
    scale_size_continuous(range = c(1,4)) +
    ggthemes::scale_fill_gradient2_tableau(palette="Temperature Diverging")+
    #scale_fill_viridis() +
    
    # General theme:
    theme_void() + 
    theme(legend.position="none") +
    coord_equal()

png(file=str_c(imgwdy,"autres_especes_2000_",CY,".png"),8,8,units="in",res=300)
print(g)
dev.off()
#############
# Bilan des espèces 2022
###############

bilesp<-choice_c(bilesp,
    dc=c(5),
    taxa=taxa,
    start_year=CY,
    end_year=CY,
    silent=FALSE)
bilesp<-charge(bilesp)
bilesp<-connect(bilesp)
bilesp<-calcule(bilesp)

png(file=str_c(imgwdy,"autres_especes.png"),8,8,units="in",res=300)
ggplot(bilesp@calcdata, aes(x="",y=(Effectif / sum(Effectif))*100,fill=taxa_stage))+
    geom_bar(,width=1, color="white", stat = "identity",)+
    ggthemes::scale_fill_tableau()+
    theme_void()+
    geom_text(aes(y = round(Effectif / sum(Effectif) * 100, 1), label = Effectif), 
        position = position_stack(vjust = 0.5), color = "white", size=6)+
    coord_polar("y", start=0)
dev.off()
@

<<silurus, echo=FALSE, eval=FALSE,include=FALSE >>=
rmi<-new("report_mig_interannual")
rmi<-choice_c(rmi,
    dc=c(5),
    taxa=c("Silurus glanis"),
    stage=c("IND"),
    start_year="1996",
    end_year=CY,
    silent=TRUE)
rmi<-charge(rmi)
rmi<-connect(rmi,check=TRUE,silent=FALSE)	
rmi<-calcule(rmi)

# utilisation de la méthode plot pour générer un graphique des densités
# puis modification des couleurs du titre et de y
plot(rmi,plot.type="density",silent=TRUE)
g<-get("g",envir=envir_stacomi)
nb_annee<-length(unique(rmi@data$bjo_annee))
mycolorramp <- colorRampPalette(c('#020731','#3862C6','#6E7587','#806641','#AE956D'))

colors<-rev(mycolorramp(nb_annee))
#============================================
png(filename=str_c(imgwdy,"rmi_density_sil.png"))
g+ggplot2::scale_fill_manual(values=colors)+
    ggplot2::ggtitle("")+
    theme(
        panel.border = element_blank(),
        panel.background = element_blank(),
        panel.grid.minor = element_line(colour = "white"),
        panel.grid.major = element_line(colour = "white"),
        panel.grid.major.x = element_line(colour = "white"))
dev.off()
#============================================
plot(rmi,plot.type="barchart",timesplit="mois",silent=TRUE)
g <- get("g1",envir=envir_stacomi)
cols <- c("max" = "#012746","min" = "#6C3E00",">=moy" = "#327AB5", "<moy" = "#D29035","hist_mean"="black","hist_range"="grey","?"="#D26435")
fills <- c("max" = "#043C6B","min" = "#6C3E00",">=moy" = "#558AB5", "<moy" = "#D2A25F","hist_mean"="black","hist_range"="grey","?"="#D26435")
g <- g+scale_colour_manual(name=CY,values=cols,limits=c("min","max","<moy",">=moy","hist_mean","hist_range","?"))
g <- g+scale_fill_manual(name=CY,values=fills,limits=c("min","max","<moy",">=moy","hist_mean","hist_range","?"))
g <- g+ggtitle("")
#============================================
png(filename=str_c(imgwdy,"barchart_bmi_sil.png"))
print(g)
dev.off()
#============================================
#png(filename=str_c(imgwdy,"plot_seasonal_trm.png"),width=14,height=10,unit="cm",res=300)
#plot(rmi,plot.type="seasonal",timesplit="semaine") 
#dev.off()

# ====== Bilan mensuel ===============

mmm <- summary(rmi,silent=TRUE)$'5' 
mmm <- mmm[,-1]
colnames(mmm) <- c("Mois", "Min*", "Moyenne*", "Max*", "N (2022)")
xtmmm<-xtable(mmm,caption="Migrations mensuelles des silures dans la passe à bassins du barrage d'Arzal, $N$ nombre, * correspondent à
        la période 1996-2022. min* minimum mensuel, max* maximum mensuel, moyenne* moyenne des effectifs mensuels.",
    label="table_trm_mois",
    digits=c(0,0,0,0,0,0),
    display = c("s","s","f","f", "f", "f"))
path_y=file.path(tabwdy,
    paste(5,"_",
        paste(rmi@taxa@taxa_selected,collapse="_"),"_",
        paste(rmi@stage@stage_selected,collapse="_"),"_"
        ,"mensuel.tex",sep=""),fsep ="")
print(xtmmm,
    file=path_y,
    format.args = list(big.mark = " ", decimal.mark = ","),
    table.placement=c("htbp")#,
#include.rownames = FALSE => OK set as global options
)
#vvv[["LPM"]]<- list()# normalement vient du rapport de l'années précédente
vvv[["TRM"]][["path_y"]]<-gsub("C:/workspace/","../../../",path_y)
save(vvv,file=str_c(datawdy,"vvv.Rdata"))


@

<<report_annual_sil, echo=FALSE, eval=FALSE,include=FALSE >>=
###############################
# Bilan annuel des migrations
###############################
ra<-new("report_annual")
ra<-choice_c(ra,
    dc=c(5),
    taxa=c("Silurus glanis"),
    stage=c("IND"),
    start_year=1996,
    end_year=CY,
    silent=TRUE)
ra <- connect(ra,silent=FALSE)

xtra<-stacomiR::xtable(ra,
    caption="Silures observés dans la passe à bassins du barrage
        d'Arzal (passe à fentes verticales).",
    label="table_bilanannuel_sil",
    dc_name=c("P. bassins")		
)
# below not run but one can create a file as following

path=file.path(tabwdy,
    paste(paste(ra@dc@dc_selected,collapse="_"),"_",
        paste(ra@taxa@taxa_selected,collapse="_"),"_",
        paste(ra@stage@data$stage_selected,collapse="_"),"_",
        ra@start_year@year_selected,"to",
        ra@end_year@year_selected,".tex",sep=""),fsep ="")
# the following uses the "addtorow" argument which creates nice column headings,
# format.args creates a thousand separator
# again this will need to be saved in a file using the file argument
print(xtra,
    file=path,
    add.to.row= list(pos=list(0),
        command=				
            "\\multicolumn{2}{c}{\\textit{Silurus glanis}}  \\\\
            \\multicolumn{2}{c}{Indéterminé} \\\\"),		
    include.rownames = TRUE,
    include.colnames = FALSE,
    format.args = list(big.mark = " ", decimal.mark = ","),
    booktabs=TRUE
)

# some manual editing needed....
#===================================================
png(filename=str_c(imgwdy,"bilan_annuel_sil.png"))
barplot(ra,args.legend=list(x="topleft",bty = "n"),
    col="orchid4",
    ylab="Effectif (Silure)")
dev.off()
#===================================================
# total 


vvv[["SIL"]][["path"]] <- gsub("C:/workspace/","../../../",path)

somme<-round(tapply(ra@data$effectif,ra@data$annee,sum))
indiceCY <- match(as.character(CY),names(somme))

save(vvv,file=str_c(datawdy,"vvv.Rdata"))
@

<<report_sample_char_silurus, echo=FALSE, eval=FALSE,include=FALSE >>=
library("stacomiR")

# launching stacomi without selecting the scheme or interface
stacomi(gr_interface=FALSE,
    login_window=FALSE,
    database_expected=TRUE)

r_sample_char <- new("report_sample_char")
r_sample_char <- choice_c(r_sample_char,
    dc=c("5"),
    taxa=c("Silurus glanis"),
    stage=c("IND"),
    par=c("C001"),
    horodatedebut="1998-01-01",
    horodatefin=str_c(CY,"-12-31"),
    silent=FALSE)
r_sample_char <- connect(r_sample_char)
r_sample_char <- calcule(r_sample_char,silent=TRUE)



png(filename=str_c(imgwdy,"size_sil.png"))
ggplot(r_sample_char@data) +
    geom_boxplot(aes(x=annee,y=car_valeur_quantitatif, fill=tax_nom_latin), outlier.alpha = 0) +
    ggplot2::ylab("taille video (mm)")+
    ggplot2::xlab("annee")+
    geom_jitter(aes(x=annee,y=car_valeur_quantitatif, col=tax_nom_latin),
        width = 0.2, 
        height = 0.2, 
        alpha=0.5)+
    theme_bw() 
dev.off()
@

\clearpage
\onecolumn
\section{Annexes}


\paragraph{Calculs extraits de la base de données du barrage.}

La base de données du barrage collecte les informations relatives aux niveaux et
au fonctionnement des vannes au pas de temps de 10 minutes. Le fichier des données extrait de la base de données du barrage
contient \Sexpr{num(vvv$fonct_pass$nb_lignes)} lignes. A partir de ce dernier un
script de traitement extrait les temps et les modes de fonctionnement de la
passe (Figure \ref{figure_schema_fonctionnement}). 
Les sondes utilisées en
référence ont parfois des valeurs manquantes,
 \Sexpr{num(vvv$fonct_pass$niveau_mer_barrage_manquant_rempl)} et \Sexpr{num(vvv$fonct_pass$niveau_vilaine_barrage_manquant_rempl)} respectivement 
 pour les niveaux aval (mer) et amont (Vilaine).
Pour les niveaux mer, après correction, en utilisant l'une ou l'autre des
sondes, le nombre de valeurs manquantes restantes pour lesquelles les deux sondes n'ont pas de
valeur est de \Sexpr{num(vvv$fonct_pass$niveau_mer_manquant_final)}. En Vilaine,
cette année la correction correspond à
\Sexpr{num(vvv$fonct_pass$niveau_vilaine_manquant_final)} pour les niveaux aval et amont.
Les corrections des niveaux de la mer
\Sexpr{num(vvv$fonct_pass$pb_niveau_mer_inf_3.5)} \footnote{Suppression des valeurs
inférieures à -3.5 m NGF.}, du sas aval \footnote{Le dernier bassin en aval de
la passe, la différence de niveaux entre ce bassin et la mer conditionne le
fonctionnement de la vanne aval, suppression des valeurs en dehors de la gamme
[-1m,2.5m].} correspondent à \Sexpr{num(vvv$fonct_pass$pb_niveau_sas)} lignes et des
dérives de codeur sur la vanne mer \footnote{Suppression des valeurs en dehors de la gamme
[-1.72m,2.5m] correspondant à la course normale de la vanne.} à
\Sexpr{num(vvv$fonct_pass$pb_hauteur_vanne_mer)} lignes. 
Au final \Sexpr{num(vvv$fonct_pass$pb_na)} lignes manquent des données permettant de
calculer le fonctionnement de la passe (Figure \ref{figure_fonctionnement_passe}). Le fichier de calcul des temps de
fonctionnement réintégré dans stacomiR comporte
\Sexpr{num(vvv$fonct_pass$nb_lignes_t_periodefonct)} lignes.
\begin{figure}[htpb]
\centering
\includegraphics[width=\textwidth]{2022/detail_fonct_passe_2.png}
\caption{Illustration du fonctionnement de la passe lors d'un fonctionnement
normal en mai. A chaque cycle de marée, le niveau de la mer varie entre +2 m et
-2m environ (en noir). Le niveau Vilaine (.- bleu) varie peu et reste
autour de 1m80. La vanne amont (en marron clair) s'ouvre  dès que le niveau mer
descend 30 cm en dessous du niveau Vilaine, c'est l'entrée en régulation de la
passe. La vanne aval (.... violets) ajuste le niveau du SAS (courbe bleue)
pour maintenir une chute constante à l'aval de la passe à l'aide d'une
régulation par l'automate. 
 L'arrêt pour maintenance le 17 lors de la marée montante se traduit par une
 fermeture de la vanne amont (trait horizontal supplémentaire). L'état de la
 passe est calculée pour chaque période de 10 minutes (en bas).
}
\label{detail_fonct_passe_2}
\end{figure}


\begin{figure}[htpb]
\centering
\includegraphics[width=0.8\textwidth]{2022/detail_fonct_passe_1.png}
\caption{Illustration du fonctionnement de la passe après la remise en route
de la passe en avril. En ordonnée les niveaux mer (noir), vilaine
(.-), sas (en bleu), niveau vanne mer (pointillés violet), niveau vanne Vilaine (ligne marron
continue). L'état de la passe est calculée pour chaque période de 10 minutes (en bas).
Les 10 et 11 après midi, la position basse de la vanne amont (vanne fermée)
indique une fermeture de la passe.}
\label{detail_fonct_passe_1}
\end{figure}


\begin{figure}[ht]
\centering
\includegraphics[width=0.6\textwidth]{2022/debit_passe_mesure.png}
\caption{Débit calculé dans la passe en 2022, mesures de l'automate du barrage.}
\label{debit_passe_mesure}
\end{figure}


\begin{figure}[ht]
\centering
\includegraphics[width=0.6\textwidth]{2022/debit_passe_calcul.png}
\caption{Débit recalculé dans la passe en 2022, après correction des valeurs
aberrantes et prise en compte du noyage aval de la passe.}
\label{debit_passe_calcul}
\end{figure}


\begin{figure}[hp]
\centering
\includegraphics[width=0.9\textwidth]{2022/report_df_annee.png} 
\caption{Bilan du fonctionnement de la passe lors de l'année 2022. En orange
il est possible de suivre les périodes de haute mer où la passe est fermée, les
périodes où les bandes sont les plus larges correspondent à des périodes de
vives eaux et également en hiver aux périodes où la gestion de la
Vilaine est plus réduite. Les arrêts nocturnes de la passe sont visibles en mai
- juin - juillet. En septembre et octobre le passage en "mode étiage" réduit la
durée de fonctionnement de la passe aux quelques heures qui précèdent la marée
haute. En hiver, en période de crue, la passe est à l'arrêt.}
\label{report_df_annee}
\end{figure}

\begin{figure}[hp]
\centering
\includegraphics[width=0.95\textwidth]{2022/report_df_fct_2003_2010.png} 
\caption{Bilan mensuel du fonctionnement de la passe à bassins d'Arzal de 2003
à 2010.}
\label{report_df_fct_2003_2010}
\end{figure}




\begin{figure}[hp]
\centering
\includegraphics[width=\textwidth]{2022/bmm_alose.png}
\caption{Bilan de la migration des aloses en 2022. Effectifs journaliers et
fonctionnement des dispositifs de franchissement et de comptage.}
\label{bmm_alose}
\end{figure}

\begin{figure}[hp]
\centering
\includegraphics[width=\textwidth]{2022/bmm_mulet.png}
\caption{Bilan de la migration des mulets en 2022. Effectifs journaliers et
fonctionnement des dispositifs de franchissement et de comptage.}
\label{bmm_mulet}
\end{figure}


\begin{figure}[hp]
\centering
\includegraphics[width=\textwidth]{2022/bmm_lpm.png}
\caption{Bilan de la migration des lamproies marines en 2022. Effectifs
journaliers et fonctionnement des dispositifs de franchissement et de comptage.}
\label{bmm_lpm}
\end{figure}




\paragraph{Entretien de la passe}
L'historique des modifications effectuées depuis la mise en service de
la passe à bassins est décrit au Tableau \ref{table_entretien_passe}.

\begin{table}[htb]
\begin{tabular}{p{0.1\textwidth}p{0.8\textwidth}}
\toprule
Année & Intervention\\
\midrule
1998 & Mise en place du mode "étiage" pour maintenir le fonctionnement
de la passe à bas débit.\\
2000 & Reprogrammation des automatismes pour éviter le vieillissement
prématuré de la centrale hydraulique aval.\\
2005 & Changement du système vidéo, remplacement par un système
numérique. \\
2005 & Changement de la vanne aval (corrosion).\\
2010 &  Remplacement des têtes des vérins aval corrodées par des têtes en
inox.\\
2011 & Modernisation des armoires électrique amont et aval,
reprogrammation des automatismes.\\
2012 & Pose d'une vanne montée sur poulie sur le canal de débit d'appoint
pour faciliter la réouverture rapide du canal, et favoriser la gestion
d'étiage.\\
2013 & Rénovation du local d'accueil de la passe à bassins (peinture,
gradin).\\
2014 & Rénovation du local d'accueil de la passe à bassins (téléviseur,
luminaires, prises \ldots{}).\\
2016 & Réparation du caisson lumineux après plusieurs submersions. Etude
de la possibilité d'installer un caisson étanche avec un éclairage par
leds.\\
2017-18 & Rénovation des vérins de la porte aval.\\
2020 & Changement de pièces sur les vérins de la porte aval.\\
2021 & Renforcement des structure du capteur de fin de course aval, Remplacement
des joints de la vanne intermédiaire.\\
2022 & TODOTODO\\
\bottomrule
\end{tabular}
\caption{Entretien historique de la passe à poissons.}
\label{table_entretien_passe}
\end{table}





\clearpage
Versions précédentes des rapports annuels (table \ref{table_references}).


\begin{table}[htbp]
\centering
\caption{Rapports précédents concernant la passe à bassins.}
\begin{tabular}{lp{7cm}}
\toprule
Année & Rapport \\
\midrule
2022 &
\href{TODO}{Suivi
de la passe à bassins, 2021} \\
2021 &
\href{https://eptbvilaine56.sharepoint.com/:b:/g/extranet/EX0SnyoGmBlMsO-6-Il8wugBCHYxha3l2A-5tA9yTCqwbg?e=XukC2d}{Suivi
de la passe à bassins, 2020} \\
2020 &
\href{https://eptbvilaine56.sharepoint.com/:b:/g/extranet/EQl4smhm635FgMPzE9bFyxsB_9ZMmVLH34BJLfwieJKuUA?e=dtqKYE}{Suivi
de la passe à bassins, 2019} \\
2019 &
\href{https://eptbvilaine56.sharepoint.com/:b:/g/extranet/ESlFdwgrzNZPjHy2CamDrh4Bd-wJB1BhJ-Hf19RuTZlpgw?e=3pPkHa}{Dynamique de la population de Mulet porc \textit{Chelon ramada} (Risso 1827) dans le bassin versant de la Vilaine}\\
2019 & 
\href{https://eptbvilaine56.sharepoint.com/:b:/g/extranet/EfsNAFGO4sRAoEb-9-SEERoBJAxYBJVWvF-9OVVryuF8QA?e=G5x6Ij}{Suivi
de la passe à bassins, 2018}\\
2018 &
\href{https://eptbvilaine56.sharepoint.com/:b:/g/extranet/EddDt8hE-z5KvA3qWm8RiUYBiawsguFwtT101pmeEXjEiQ?e=TdLuRC}{Suivi
de la passe à bassins, 2017}\\
2017 &
\href{https://eptbvilaine56.sharepoint.com/:b:/g/extranet/EZovsRks3WFKsse_rsnnqh0BAcwjBH5ofFK1pjdwtAe6Dw?e=sRP0k9}{Suivi
de la passe à bassins, 2016}\\
2016 &
\href{https://eptbvilaine56.sharepoint.com/:b:/g/extranet/EUaIB9CdQItLkPTR0banFZYBv7DnfD7uNSezUSFVD9tfcw?e=ZAWC9t}{Suivi
de la passe à bassins, 2015}\\
2015 &
\href{https://eptbvilaine56.sharepoint.com/:b:/g/extranet/EQCdJUAzgLlJpqe-HgXcbn4BvTlV7Xool5zCmmV-fZaolg?e=dvEObL}{Suivi
de la passe à bassins, 2014}\\
2014 &
\href{https://eptbvilaine56.sharepoint.com/:b:/g/extranet/Effnw5jtEPFHmxCcqlWiTBsB0Cm29yADN5bSREbOi1yTzA?e=YS1Ref}{Suivi
de la passe à bassins, 2013}\\
2013 &
\href{https://eptbvilaine56.sharepoint.com/:b:/g/extranet/Ed6J-KFKTc1EhcXyxox1eU4B86i9IYhY53FuP2ilW9TdhA?e=pagXSD}{Suivi
de la passe à bassins, 2012}\\
2012 &
\href{https://eptbvilaine56.sharepoint.com/:b:/g/extranet/EWQJkGynJO9FkLtMc0evglwBhVC3k2ORqwqhA_ez-fecKQ?e=xaK6zo}{Suivi
de la passe à bassins, 2011}\\
2010 &
\href{https://eptbvilaine56.sharepoint.com/:b:/g/extranet/ETTqqTILtm5OjioHyGGAsooBsGVP5CgR9fE-xCj-evifLA?e=2I4CbN}{Suivi
de la passe à bassins, 2009}\\
2009 &
\href{https://eptbvilaine56.sharepoint.com/:b:/g/extranet/ESOYjucqRlRNm4hXNuO3-EgBBOTq0zMqmhq0u125J21Yxw?e=EbCzao}{Suivi
de la passe à bassins, 2008}\\
%
\bottomrule
\end{tabular}
\label{table_references}
\end{table}

\bigskip
\paragraph{Remerciements}

La passe fonctionne au quotidien grâce au travail d'entretien de suivi et
d'intervention des barragistes : Alban Le Guen, Cyril Faucon, Johann Dahlem,
laurent Philippot, Thierry Besnard. Nous tenons à les remercier pour leur aide et leur
disponibilité.
\bigskip

\vfill
\paragraph{Ressources en ligne} ~

Observatoire des poissons migrateurs en Bretagne~:
\href{http://www.observatoire-poissons-migrateurs-bretagne.fr}{{http://www.observatoire-poissons-migrateurs-bretagne.fr}}

Association Loire Grands Migrateurs (LOGRAMI)~:
\href{http://www.logrami.fr}{{http://www.logrami.fr}}

Migrateurs Garonne Dordogne Charente Seudre (MIGADO)~:
\href{http://www.migado.fr}{{http://www.migado.fr}}

Cellule Migrateurs Charente Seudre (MIGADO)~:
\href{http://www.migrateurs-charenteseudre.fr}{{http://www.migrateurs-charenteseudre.fr}}

Saumon-Rhin~:   
\href{https://www.saumon-rhin.com/}{{https://www.saumon-rhin.com/}}

Fédération de pêche de la Somme ~: 
\href{https://peche80.com/}{{https://peche80.com/}}

Seine-Normandie Migrateurs (SEINORMIG)~:    
\href{https://www.seinormigr.fr/}{{https://www.seinormigr.fr/}}

Stations de suivi INRAe-OFB~:      
\href{https://bretagne-environnement.fr/bresle---oir---scorff---nivelle-trois-decennies-observations-recherche-poissons-migrateurs}{{https://bretagne-environnement.fr/bresle---oir---scorff---nivelle-trois-decennies-observations-recherche-poissons-migrateurs}}

Migrateurs Adour (MIGRADOUR)~:                          
\href{https://www.migradour.com/activite/site-index-soustons/}{{https://www.migradour.com/activite/site-index-soustons/}}

Migrateurs Rhône-Méditerranée (MRM)~:            
\href{https://www.migrateursrhonemediterranee.org/}{{https://www.migrateursrhonemediterranee.org/}}



%\twocolumn
% biblio commune aux différentes années
\printbibliography

\clearpage

\onecolumn
\thispagestyle{empty}
\pagecolor{bleu_EV}
\begin{tcolorbox}[enhanced jigsaw,
                  colback=turquoise_EV!30,%gray background
                  colframe=turquoise_EV,% black frame colour
                  width=\textwidth,% Use 5cm total width,
                  arc=3mm, auto outer arc,
                  boxrule=5pt,
                  drop shadow={bleu_EV!50!gray!80}
                 ]
\textbf{Résumé}\par

 \vspace{8mm}
    
 Ce rapport présente le bilan de suivi de la passe à bassins d'Arzal en
    \Sexpr{num(CY)}. Il détaille le fonctionnement de la passe, de son système
    d'enregistrement vidéo, ainsi que les effectifs annuels des principales
    espèces ayant transité par la passe du barrage d'Arzal à l'estuaire de la
    Vilaine. En \Sexpr{num(CY)}, 
    \Sexpr{num(vvv$ALA$NCY)} aloses (\textit{Alosa
    Sp.}), 
    \Sexpr{num(vvv$LPM$NCY)} lamproies marines (\textit{Petromyzon
    marinus}), 
    \Sexpr{num(vvv$TRM$NCY)} truites de mer (\textit{Salmo trutta trutta}),
    \Sexpr{num(vvv$SAT$NCY)} saumons (\textit{Salmo salar}) et
    \Sexpr{num(vvv$MUP$NCY)} mulets porcs (\textit{Chelon ramada}) ont été
    comptabilisés à la passe d'Arzal. Le COVID n'a pas affecté le suivi de la
    passe. \par
        
   \vspace{8mm}
    
   \textbf{Abstract}\par
   
    \vspace{8mm}
  
    This report presents the monitoring of the pool fishway at Arzal in
    \Sexpr{num(CY)}. It details the operation of the fishway and it's recording video
    device, along with the annual number of the main species crossing the Arzal
    Dam in the Vilaine esturay.
    In \Sexpr{num(CY)}, 
    \Sexpr{num(vvv$ALA$NCY)} shads (\textit{Alosa Sp.}),
    \Sexpr{num(vvv$LPM$NCY)} sea lampreys (\textit{Petromyzon marinus}), 
    \Sexpr{num(vvv$TRM$NCY)} sea trouts (\textit{Salmo trutta trutta}),
    \Sexpr{num(vvv$SAT$NCY)} salmons (\textit{Salmo salar}) 
    and \Sexpr{num(vvv$MUP$NCY)} (\textit{Chelon ramada}) mulet have been counted
    at the Arzal fishway. COVID did not induce any breakdown in monitoring. \par

   

    \vspace{8mm}
    \textbf{Mots clés:}\par
     \textit{mulet, lamproie marine, alose, stacomi}\par 
    \vspace{8mm}    
     \textbf{\textit{Keywords:}}\par
     \textit{mulet, lamprey, shad, stacomi}  
\end{tcolorbox}


\vfill
\color{turquoise_EV}
\hfill\makebox[0.5\textwidth][r]{%
\begin{minipage}{0.4\textwidth}  
\tiny
\noindent\hrulefill\par 
\noindent Rapport \LaTeX \par
packages R : \vspace{1mm}

StacomiR \colcitep{turquoise_EV}{briand_stacomir_2017}\par
\LaTeX \ :Hmisc, xtable, stargazer, tables, knitr \par
graphiques : stacomiR, ggplot2, lattice, ggthemr, packcircles, colorspace\par
traitements : stringr, lubridate, reshape2, dplyr\par
diagrammes : diagrammeR \\
base : readxl, RPostgres, DBI, stacomirtools\par
\vspace{1mm}
Dernière compilation : le \today\par
\Sexpr{sanitize(print(version["version.string"]))}\par
\noindent\hrulefill\par
\end{minipage}}

\clearpage

\end{document}

